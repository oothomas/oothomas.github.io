<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace</title>

  <!-- 1) Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- 2) VTK.js for 3D mesh visualization -->
  <script src="https://unpkg.com/vtk.js"></script>

  <!-- Basic inline styles (you can customize) -->
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #FAFAFA;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    #plotlyDiv {
      width: 600px;
      height: 500px;
      margin-bottom: 1em;
      border: 1px solid #ccc;
      background: white;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      background-color: #EAEAEA;
      border: 1px solid #ccc;
      margin-top: 1em;
    }
    .controls {
      margin-bottom: 1em;
    }
    .button {
      margin: 0 5px 10px 0;
    }
    #variantSlider {
      width: 800px;
      margin-top: 1em;
    }
  </style>
</head>
<body>

  <h1>Interactive Morphospace</h1>
  <p>
    This page fetches PCA data from the API, lets you pick a "source" and "target" point,
    then requests an interpolated series of shapes that you can explore in 3D.
  </p>

  <div class="controls">
    <button id="fetchDataBtn" class="button">Fetch PCA Data</button>
    <button id="sourceBtn" class="button">Set Source Point</button>
    <button id="targetBtn" class="button">Set Target Point</button>
    <button id="computeBtn" class="button">Compute & Interpolate</button>
  </div>

  <!-- Plotly chart for PCA scatter -->
  <div id="plotlyDiv"></div>

  <!-- Slider for stepping through shapes -->
  <input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />

  <!-- Container for VTK 3D visualization -->
  <div id="vtkContainer"></div>

  <script>
    //
    // GLOBALS
    //
    let pcaData = null;       // Will hold the PCA scores from "get-initial"
    let sourcePoint = null;   // [xVal, yVal] chosen on the plot
    let targetPoint = null;   // [xVal, yVal] chosen on the plot
    let selectingSource = false;
    let selectingTarget = false;

    let decodedShapes = null; // Array of shapes from "interpolate" => NxVx3
    let faces = null;         // Shared face array => Fx3
    let renderer = null;
    let renderWindow = null;
    let vtkActor = null;
    let slider = null;

    //
    // 1) FETCH PCA DATA
    //
    async function fetchPCAData() {
      try {
        const response = await fetch("https://3.138.141.8:443/get-initial", { method: 'GET' });
        if (!response.ok) {
          throw new Error(`Failed to fetch. HTTP ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();
        pcaData = data.components; // Nx15 array
        console.log("Fetched PCA data:", pcaData);
        plotPCAScatter(pcaData);
      } catch (err) {
        alert("Error fetching PCA data: " + err);
        console.error(err);
      }
    }

    //
    // 2) PLOT PCA SCATTER (e.g. PC1 vs PC2)
    //
    function plotPCAScatter(components) {
      if (!components || components.length === 0) {
        console.warn("No PCA data to plot.");
        return;
      }
      // Hard-coded to PC1 (index 0) and PC2 (index 1)
      const xVals = components.map(row => row[0]);
      const yVals = components.map(row => row[1]);

      const trace = {
        x: xVals,
        y: yVals,
        mode: 'markers',
        type: 'scatter',
        marker: { size: 6, color: 'rgba(255,0,0,0.6)' }
      };

      const layout = {
        title: 'PCA Morphospace (PC1 vs PC2)',
        xaxis: { title: 'PC1' },
        yaxis: { title: 'PC2' }
      };

      Plotly.newPlot('plotlyDiv', [trace], layout);

      // Attach click event
      const plotDiv = document.getElementById('plotlyDiv');
      plotDiv.on('plotly_click', function(eventData) {
        if (eventData.points && eventData.points.length > 0) {
          const pt = eventData.points[0];
          const xVal = pt.x;
          const yVal = pt.y;
          // If user indicated "Set Source" or "Set Target"
          if (selectingSource) {
            sourcePoint = [xVal, yVal];
            alert(`Source point set to: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
            selectingSource = false;
          } else if (selectingTarget) {
            targetPoint = [xVal, yVal];
            alert(`Target point set to: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
            selectingTarget = false;
          }
        }
      });
    }

    //
    // 3) POST SOURCE/TARGET => GET INTERPOLATED SHAPES
    //
    async function computeInterpolation() {
      if (!sourcePoint || !targetPoint) {
        alert("Please choose both a source and a target point first!");
        return;
      }

      // We assume only PC1 and PC2 are set; the rest = 0
      const pcScores = [
        [ sourcePoint[0], sourcePoint[1], 0,0,0,0,0,0,0,0,0,0,0,0,0 ],
        [ targetPoint[0], targetPoint[1], 0,0,0,0,0,0,0,0,0,0,0,0,0 ]
      ];

      const payload = { pc_scores: pcScores };
      console.log("Sending payload to /interpolate:", payload);

      try {
        const resp = await fetch("https://3.138.141.8:443/interpolate", {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          throw new Error(`Interpolation error: ${resp.status} - ${resp.statusText}`);
        }
        const interpData = await resp.json();
        decodedShapes = interpData.shapes; // NxVx3
        faces = interpData.faces;          // Fx3
        console.log("Received shapes:", decodedShapes);
        console.log("Faces:", faces);

        // Initialize VTK scene if not done
        setupVTKScene();

        // Display shape #0 and configure slider
        slider = document.getElementById('variantSlider');
        slider.max = decodedShapes.length - 1;
        slider.value = 0;
        updateDisplayedVariant(0);
      } catch (err) {
        alert("Error computing interpolation: " + err);
        console.error(err);
      }
    }

    //
    // 4) SETUP VTK SCENE ONCE
    //
    function setupVTKScene() {
      if (renderer) {
        // Already set up
        return;
      }
      const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
        rootContainer: document.getElementById('vtkContainer'),
        containerStyle: {
          width: '100%',
          height: '100%',
          position: 'relative',
          overflow: 'hidden'
        }
      });
      renderWindow = fullScreenRenderer.getRenderWindow();
      renderer = fullScreenRenderer.getRenderer();

      // Create a single mapper + actor. We'll update the PolyData for each shape.
      const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
      vtkActor = vtk.Rendering.Core.vtkActor.newInstance();
      vtkActor.setMapper(mapper);
      renderer.addActor(vtkActor);
      renderer.resetCamera();
      renderWindow.render();
    }

    //
    // 5) UPDATE DISPLAYED VARIANT (VERTICES+FACES) INTO VTK ACTOR
    //
    function updateDisplayedVariant(index) {
      if (!decodedShapes || !faces) return;
      index = parseInt(index);
      if (index < 0 || index >= decodedShapes.length) return;

      const pointsArray = decodedShapes[index]; // Vx3
      const nVerts = pointsArray.length;
      const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
      vtkPoints.setNumberOfPoints(nVerts);
      for (let i = 0; i < nVerts; i++) {
        vtkPoints.setPoint(i, pointsArray[i][0], pointsArray[i][1], pointsArray[i][2]);
      }

      // Each face = 3 vertex indices => need a cell array of [3, idx0, idx1, idx2]
      const nFaces = faces.length;
      const polys = new Uint32Array(nFaces * 4);
      for (let f = 0; f < nFaces; f++) {
        const offset = f * 4;
        polys[offset + 0] = 3;  // number of vertices in this face
        polys[offset + 1] = faces[f][0];
        polys[offset + 2] = faces[f][1];
        polys[offset + 3] = faces[f][2];
      }

      const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
      polyData.setPoints(vtkPoints);
      polyData.getPolys().setData(polys);

      // If you have error scalars, attach them here:
      // let scalars = Float32Array.from(errorArrayForThisIndex);
      // polyData.getPointData().setScalars(vtkDataArray.newInstance({
      //   name: 'Error',
      //   values: scalars,
      // }));

      vtkActor.getMapper().setInputData(polyData);
      renderer.resetCamera();
      renderWindow.render();
    }

    //
    // 6) WIRE UP BUTTONS AND SLIDER
    //
    document.getElementById('fetchDataBtn').onclick = fetchPCAData;
    document.getElementById('sourceBtn').onclick = () => {
      selectingSource = true;
      selectingTarget = false;
      alert("Click any point in the scatter plot to set the SOURCE point.");
    };
    document.getElementById('targetBtn').onclick = () => {
      selectingTarget = true;
      selectingSource = false;
      alert("Click any point in the scatter plot to set the TARGET point.");
    };
    document.getElementById('computeBtn').onclick = computeInterpolation;

    // Slider for switching shapes
    document.getElementById('variantSlider').oninput = (e) => {
      updateDisplayedVariant(e.target.value);
    };
  </script>

</body>
</html>
