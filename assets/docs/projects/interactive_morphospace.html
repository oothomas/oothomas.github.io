<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace (Client-side Alignment & Error Coloring)</title>

  <!-- Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- VTK.js for 3D rendering -->
  <script src="https://unpkg.com/vtk.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    #plotlyDiv {
      width: 600px;
      height: 480px;
      border: 1px solid #ccc;
      background: white;
      margin-bottom: 1em;
    }
    #variantSlider {
      width: 800px;
      margin: 10px 0 20px 0;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
    }
  </style>
</head>
<body>

<h1>Interactive Morphospace Viewer</h1>
<p>
  This page allows you to:
</p>
<ol>
  <li>Select which PCs to plot on X/Y axes.</li>
  <li>Choose a source and target point from the scatter plot.</li>
  <li>Fetch and interpolate shapes from the server.</li>
  <li>Perform client-side <b>farthest-point sampling</b> + <b>SVD</b> alignment on all returned meshes.</li>
  <li>Color the meshes by per-vertex <b>error</b> (distance from reference shape #0).</li>
  <li>Use the slider to step through the interpolated series.</li>
</ol>

<!-- Controls for fetching data, picking PCs, and selecting points -->
<div class="controls">
  <button id="fetchDataBtn">Fetch PCA Data</button>

  <label for="xPCSelect">X PC:</label>
  <select id="xPCSelect"></select>

  <label for="yPCSelect">Y PC:</label>
  <select id="yPCSelect"></select>

  <button id="sourceBtn">Set Source Point</button>
  <button id="targetBtn">Set Target Point</button>
  <button id="computeBtn">Compute & Interpolate</button>
</div>

<!-- The Plotly scatter plot for PCA -->
<div id="plotlyDiv"></div>

<!-- Slider to pick which shape variant to display -->
<input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />

<!-- Container for VTK 3D view -->
<div id="vtkContainer"></div>

<script>
// ------------------------------------------------------
// GLOBALS
// ------------------------------------------------------
let pcaData = null;       // Nx15 from "/get-initial"
let specimenIds = null;   // optional
let xPCIndex = 0;         // which column is X PC
let yPCIndex = 1;         // which column is Y PC

let selectingSource = false;
let selectingTarget = false;
let sourcePoint = null;   // [xVal, yVal] in PC space
let targetPoint = null;   // [xVal, yVal] in PC space

// After interpolation
let originalShapes = null;    // raw shapes from server: N x V x 3
let faces = null;             // F x 3
let alignedShapes = null;     // N x V x 3 (after alignment)
let errorsArray = null;       // N x V (error distances from reference)
let globalErrorMin = 0;
let globalErrorMax = 1;

// VTK / Rendering
let renderer = null;
let renderWindow = null;
let vtkActor = null;          // Reused for each shape
let lookupTable = null;       // For coloring errors
let slider = null;

// ------------------------------------------------------
// 1) FETCH PCA DATA
// ------------------------------------------------------
async function fetchPCAData() {
  try {
    const resp = await fetch("https://morphvq.net/get-initial", { method: 'GET' });
    if (!resp.ok) {
      throw new Error(`Fetch error: ${resp.status} - ${resp.statusText}`);
    }
    const data = await resp.json();
    pcaData = data.components;   // Nx15
    specimenIds = data.specimen_ids; // optional
    console.log("Fetched PCA data:", pcaData);

    fillPCSelects();
    plotPCAScatter();
  } catch (err) {
    console.error("Error fetching PCA data:", err);
    alert("Error fetching PCA data. Check console for details.");
  }
}

// ------------------------------------------------------
// 2) POPULATE PC SELECTORS
// ------------------------------------------------------
function fillPCSelects() {
  const xSelect = document.getElementById('xPCSelect');
  const ySelect = document.getElementById('yPCSelect');
  xSelect.innerHTML = "";
  ySelect.innerHTML = "";

  for (let i = 1; i <= 15; i++) {
    const optionX = document.createElement('option');
    optionX.value = i - 1;
    optionX.textContent = "PC" + i;
    xSelect.appendChild(optionX);

    const optionY = document.createElement('option');
    optionY.value = i - 1;
    optionY.textContent = "PC" + i;
    ySelect.appendChild(optionY);
  }

  xSelect.value = "0";
  ySelect.value = "1";

  xSelect.addEventListener("change", () => {
    xPCIndex = parseInt(xSelect.value);
    plotPCAScatter();
  });

  ySelect.addEventListener("change", () => {
    yPCIndex = parseInt(ySelect.value);
    plotPCAScatter();
  });
}

// ------------------------------------------------------
// 3) PLOT PCA SCATTER PLOT
// ------------------------------------------------------
function plotPCAScatter() {
  if (!pcaData) return;

  const xVals = pcaData.map(row => row[xPCIndex]);
  const yVals = pcaData.map(row => row[yPCIndex]);

  Plotly.newPlot('plotlyDiv', [{
    x: xVals,
    y: yVals,
    mode: 'markers',
    marker: { size: 8, color: 'rgba(255, 0, 0, 0.6)' }
  }], {
    title: `PCA Morphospace (PC${xPCIndex + 1} vs PC${yPCIndex + 1})`,
    xaxis: { title: `PC${xPCIndex + 1}` },
    yaxis: { title: `PC${yPCIndex + 1}` }
  });

  document.getElementById('plotlyDiv').on('plotly_click', event => {
    const point = event.points[0];
    if (selectingSource) {
      sourcePoint = [point.x, point.y];
      alert(`Source Point: ${sourcePoint}`);
      selectingSource = false;
    } else if (selectingTarget) {
      targetPoint = [point.x, point.y];
      alert(`Target Point: ${targetPoint}`);
      selectingTarget = false;
    }
  });
}

// ------------------------------------------------------
// 4) PERFORM INTERPOLATION
// ------------------------------------------------------
async function computeInterpolation() {
  if (!sourcePoint || !targetPoint) {
    alert("Please select both source and target points.");
    return;
  }

  const pcScores = [
    new Array(15).fill(0),
    new Array(15).fill(0)
  ];
  pcScores[0][xPCIndex] = sourcePoint[0];
  pcScores[0][yPCIndex] = sourcePoint[1];
  pcScores[1][xPCIndex] = targetPoint[0];
  pcScores[1][yPCIndex] = targetPoint[1];

  try {
    const resp = await fetch("https://morphvq.net/interpolate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ pc_scores: pcScores })
    });

    if (!resp.ok) {
      throw new Error(`Interpolation error: ${resp.status}`);
    }

    const result = await resp.json();
    originalShapes = result.shapes;
    faces = result.faces;

    alignedShapes = alignAllMeshes(originalShapes);
    errorsArray = computeErrors(alignedShapes[0], alignedShapes);
    const { minVal, maxVal } = findGlobalRange(errorsArray);

    globalErrorMin = minVal;
    globalErrorMax = maxVal;

    setupVTKScene();
    lookupTable = createLookupTable(globalErrorMin, globalErrorMax);

    slider = document.getElementById('variantSlider');
    slider.max = alignedShapes.length - 1;
    slider.value = 0;
    slider.oninput = e => updateDisplayedVariant(e.target.value);

    updateDisplayedVariant(0);
  } catch (err) {
    console.error("Error during interpolation:", err);
    alert("Error during interpolation. Check console for details.");
  }
}

// ------------------------------------------------------
// RENDER VTK SHAPE
// ------------------------------------------------------
function updateDisplayedVariant(index) {
  if (!alignedShapes || !faces || !errorsArray) return;

  const pointsArray = alignedShapes[index];
  const shapeErrors = errorsArray[index];

  const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
  vtkPoints.setNumberOfPoints(pointsArray.length);
  pointsArray.forEach((pt, i) => vtkPoints.setPoint(i, ...pt));

  const vtkCells = new Uint32Array(faces.length * 4);
  faces.forEach((face, i) => {
    const offset = i * 4;
    vtkCells[offset] = 3; // Triangles
    vtkCells[offset + 1] = face[0];
    vtkCells[offset + 2] = face[1];
    vtkCells[offset + 3] = face[2];
  });

  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
  polyData.setPoints(vtkPoints);
  polyData.getPolys().setData(vtkCells);

  if (shapeErrors) {
    const scalars = vtk.Common.Core.vtkDataArray.newInstance({
      name: "Error",
      values: shapeErrors
    });
    polyData.getPointData().setScalars(scalars);
  }

  vtkActor.getMapper().setInputData(polyData);
  renderer.resetCamera();
  renderWindow.render();
}
</script>

</body>
</html>
