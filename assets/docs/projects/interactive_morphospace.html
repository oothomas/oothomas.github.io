<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace (Client-side Alignment & Error Coloring)</title>

  <!-- 1) Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- 2) VTK.js for 3D rendering -->
  <script src="https://unpkg.com/vtk.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    #plotlyDiv {
      width: 600px;
      height: 480px;
      border: 1px solid #ccc;
      background: white;
      margin-bottom: 1em;
    }
    #variantSlider {
      width: 800px;
      margin: 10px 0 20px 0;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
    }
  </style>
</head>
<body>

<h1>Interactive Morphospace Viewer</h1>
<p>
  This page allows you to:
</p>
<ol>
  <li>Select which PCs to plot on X/Y axes.</li>
  <li>Choose a source and target point from the scatter plot.</li>
  <li>Fetch and interpolate shapes from the server.</li>
  <li>Perform client-side <b>farthest-point sampling</b> + <b>SVD</b> alignment on all returned meshes.</li>
  <li>Color the meshes by per-vertex <b>error</b> (distance from reference shape #0).</li>
  <li>Use the slider to step through the interpolated series.</li>
</ol>

<!-- Controls for fetching data, picking PCs, and selecting points -->
<div class="controls">
  <button id="fetchDataBtn">Fetch PCA Data</button>

  <label for="xPCSelect">X PC:</label>
  <select id="xPCSelect"></select>

  <label for="yPCSelect">Y PC:</label>
  <select id="yPCSelect"></select>

  <button id="sourceBtn">Set Source Point</button>
  <button id="targetBtn">Set Target Point</button>
  <button id="computeBtn">Compute &amp; Interpolate</button>
</div>

<!-- The Plotly scatter plot for PCA -->
<div id="plotlyDiv"></div>

<!-- Slider to pick which shape variant to display -->
<input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />

<!-- Container for VTK 3D view -->
<div id="vtkContainer"></div>

<script>
// ------------------------------------------------------
// GLOBALS
// ------------------------------------------------------
let pcaData = null;       // Nx15 from "/get-initial"
let specimenIds = null;   // optional
let xPCIndex = 0;         // which column is X PC
let yPCIndex = 1;         // which column is Y PC

let selectingSource = false;
let selectingTarget = false;
let sourcePoint = null;   // [xVal, yVal] in PC space
let targetPoint = null;   // [xVal, yVal] in PC space

// After interpolation
let originalShapes = null;    // raw shapes from server: N x V x 3
let faces = null;             // F x 3
let alignedShapes = null;     // N x V x 3 (after alignment)
let errorsArray = null;       // N x V (error distances from reference)
let globalErrorMin = 0;
let globalErrorMax = 1;

// VTK / Rendering
let renderer = null;
let renderWindow = null;
let vtkActor = null;          // Reused for each shape
let lookupTable = null;       // For coloring errors
let slider = null;


// ------------------------------------------------------
// 1) FETCH PCA DATA
// ------------------------------------------------------
async function fetchPCAData() {
  try {
    const resp = await fetch("https://3.138.141.8:443/get-initial", { method: 'GET' });
    if (!resp.ok) {
      throw new Error(`Fetch error: ${resp.status} - ${resp.statusText}`);
    }
    const data = await resp.json();
    pcaData = data.components;   // Nx15
    specimenIds = data.specimen_ids; // optional
    console.log("Fetched PCA data. Shape:", pcaData.length, "x", pcaData[0].length);

    // Fill PC dropdowns if not already done
    fillPCSelects();
    // Plot using current xPCIndex, yPCIndex
    plotPCAScatter();
  } catch (err) {
    alert("Error fetching PCA data: " + err);
    console.error(err);
  }
}


// ------------------------------------------------------
// 2) POPULATE <select> FOR X/Y PC (1..15) & HOOK CHANGES
// ------------------------------------------------------
function fillPCSelects() {
  const xSelect = document.getElementById('xPCSelect');
  const ySelect = document.getElementById('yPCSelect');

  // Clear out
  xSelect.innerHTML = "";
  ySelect.innerHTML = "";

  // Fill from PC1..PC15
  for (let i = 1; i <= 15; i++) {
    const optionX = document.createElement('option');
    optionX.value = i.toString();
    optionX.textContent = "PC" + i;
    xSelect.appendChild(optionX);

    const optionY = document.createElement('option');
    optionY.value = i.toString();
    optionY.textContent = "PC" + i;
    ySelect.appendChild(optionY);
  }

  // Default to PC1 for X, PC2 for Y
  xSelect.value = "1";
  ySelect.value = "2";
  xPCIndex = 0;
  yPCIndex = 1;

  // Hook up onChange
  xSelect.onchange = function(e) {
    xPCIndex = parseInt(e.target.value) - 1; // zero-based
    plotPCAScatter();
  };
  ySelect.onchange = function(e) {
    yPCIndex = parseInt(e.target.value) - 1;
    plotPCAScatter();
  };
}


// ------------------------------------------------------
// 3) PLOT THE PCA SCATTER (Plotly) using xPCIndex, yPCIndex
// ------------------------------------------------------
function plotPCAScatter() {
  if (!pcaData || pcaData.length === 0) {
    console.warn("No PCA data to plot or not fetched yet.");
    return;
  }
  // We'll forcibly reset source/target, since re-plot changes axes
  sourcePoint = null;
  targetPoint = null;

  const xVals = pcaData.map(row => row[xPCIndex]);
  const yVals = pcaData.map(row => row[yPCIndex]);

  const trace = {
    x: xVals,
    y: yVals,
    mode: 'markers',
    type: 'scatter',
    marker: { size: 7, color: 'rgba(255,0,0,0.6)' }
  };

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title: `PC${xPCIndex+1}` },
    yaxis: { title: `PC${yPCIndex+1}` }
  };

  Plotly.newPlot('plotlyDiv', [trace], layout);

  // Attach click event
  const plotDiv = document.getElementById('plotlyDiv');
  plotDiv.on('plotly_click', function(clickData){
    if (clickData.points && clickData.points.length > 0) {
      const pt = clickData.points[0];
      const xVal = pt.x;
      const yVal = pt.y;
      if (selectingSource) {
        sourcePoint = [xVal, yVal];
        alert(`Source set: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
        selectingSource = false;
      } else if (selectingTarget) {
        targetPoint = [xVal, yVal];
        alert(`Target set: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
        selectingTarget = false;
      }
    }
  });
}


// ------------------------------------------------------
// 4) POST SOURCE/TARGET => GET INTERPOLATED SHAPES
//    Then do client-side alignment + error coloring
// ------------------------------------------------------
async function computeInterpolation() {
  if (!sourcePoint || !targetPoint) {
    alert("Please pick both source and target points from the scatter plot!");
    return;
  }

  // We'll only set the selected PC coords for those indices,
  // all other PCs = 0.  If you want more advanced logic, adapt here.
  const pcScores = [
    new Array(15).fill(0),
    new Array(15).fill(0)
  ];
  pcScores[0][xPCIndex] = sourcePoint[0];
  pcScores[0][yPCIndex] = sourcePoint[1];
  pcScores[1][xPCIndex] = targetPoint[0];
  pcScores[1][yPCIndex] = targetPoint[1];

  const payload = { pc_scores: pcScores };
  console.log("Sending /interpolate payload:", payload);

  try {
    const resp = await fetch("https://3.138.141.8:443/interpolate", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!resp.ok) {
      throw new Error(`Interpolation error: ${resp.status} - ${resp.statusText}`);
    }
    const result = await resp.json();
    originalShapes = result.shapes; // NxVx3
    faces = result.faces;           // Fx3
    console.log("Received shapes (un-aligned):", originalShapes);
    console.log("Faces:", faces);

    // 1) Align all shapes (client-side) to shape[0]
    alignedShapes = alignAllMeshes(originalShapes);

    // 2) Compute errors relative to shape[0] after alignment
    errorsArray = computeErrors(alignedShapes[0], alignedShapes); // NxV
    let { minVal, maxVal } = findGlobalRange(errorsArray);
    globalErrorMin = minVal;
    globalErrorMax = maxVal;
    console.log("Error range:", globalErrorMin, globalErrorMax);

    // 3) Setup VTK scene if not done
    setupVTKScene();
    // 4) Create a color lookup table
    lookupTable = createLookupTable(globalErrorMin, globalErrorMax);

    // 5) Show shape #0 initially + update slider
    slider = document.getElementById('variantSlider');
    slider.min = 0;
    slider.max = alignedShapes.length - 1;
    slider.value = 0;
    updateDisplayedVariant(0);

  } catch (err) {
    alert("Error computing interpolation: " + err.message);
    console.error(err);
  }
}


// ------------------------------------------------------
// (A) FARTHEST POINT SAMPLING + (B) SVD REGISTRATION
// ------------------------------------------------------

function alignAllMeshes(shapes) {
  // shapes: N x V x 3
  const N = shapes.length;
  if (N === 0) return [];

  // We'll make a deep copy so we don't mutate original
  const out = shapes.map(shape => shape.map(pt => [...pt]));

  // 1) Fartherst point sample from the first shape => indices
  const sampleIndices = farthestPointSample(out[0], 128);

  // 2) Base points are from shape[0]
  const basePoints = sampleIndices.map(idx => out[0][idx]);

  // 3) For each subsequent shape, compute R,t => transform
  for (let i = 1; i < N; i++) {
    const currentPoints = sampleIndices.map(idx => out[i][idx]);
    const { R, t } = computeNPointRegistration(currentPoints, basePoints);
    // Apply R, t to the entire shape
    for (let v = 0; v < out[i].length; v++) {
      const p = out[i][v];
      // p' = R * p + t
      const x = p[0], y = p[1], z = p[2];
      const px = R[0][0]*x + R[0][1]*y + R[0][2]*z;
      const py = R[1][0]*x + R[1][1]*y + R[1][2]*z;
      const pz = R[2][0]*x + R[2][1]*y + R[2][2]*z;
      out[i][v][0] = px + t[0];
      out[i][v][1] = py + t[1];
      out[i][v][2] = pz + t[2];
    }
  }
  return out;
}

function farthestPointSample(points, k=128) {
  // points: V x 3
  if (points.length <= k) {
    return [...points.keys()]; // all indices
  }
  const selected = [0]; // pick index 0 initially
  const dist = new Array(points.length).fill(Infinity);

  let lastSelected = points[0];
  for (let count = 1; count < k; count++) {
    for (let i = 0; i < points.length; i++) {
      const d = euclideanDist(points[i], lastSelected);
      if (d < dist[i]) dist[i] = d;
    }
    let maxDist = -1, maxIdx = -1;
    for (let i = 0; i < dist.length; i++) {
      if (dist[i] > maxDist) {
        maxDist = dist[i];
        maxIdx = i;
      }
    }
    selected.push(maxIdx);
    lastSelected = points[maxIdx];
  }
  return selected;
}

function computeNPointRegistration(srcPoints, tgtPoints) {
  // srcPoints, tgtPoints each: k x 3
  const n = srcPoints.length;
  let srcC = [0,0,0], tgtC = [0,0,0];
  for (let i = 0; i < n; i++) {
    srcC[0] += srcPoints[i][0];
    srcC[1] += srcPoints[i][1];
    srcC[2] += srcPoints[i][2];
    tgtC[0] += tgtPoints[i][0];
    tgtC[1] += tgtPoints[i][1];
    tgtC[2] += tgtPoints[i][2];
  }
  srcC = srcC.map(v => v/n);
  tgtC = tgtC.map(v => v/n);

  // build H = sum ( (si - sC) (ti - tC)^T )
  let H = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i = 0; i < n; i++) {
    const sx = srcPoints[i][0] - srcC[0];
    const sy = srcPoints[i][1] - srcC[1];
    const sz = srcPoints[i][2] - srcC[2];
    const tx = tgtPoints[i][0] - tgtC[0];
    const ty = tgtPoints[i][1] - tgtC[1];
    const tz = tgtPoints[i][2] - tgtC[2];
    H[0][0] += sx*tx; H[0][1] += sx*ty; H[0][2] += sx*tz;
    H[1][0] += sy*tx; H[1][1] += sy*ty; H[1][2] += sy*tz;
    H[2][0] += sz*tx; H[2][1] += sz*ty; H[2][2] += sz*tz;
  }
  // SVD(H)
  const { U, S, Vt } = svd3(H);
  // R = Vt^T * U^T
  let R = matMul(matTranspose(Vt), matTranspose(U));
  if (det3(R) < 0) {
    // fix reflection
    Vt[2][0] *= -1; Vt[2][1] *= -1; Vt[2][2] *= -1;
    R = matMul(matTranspose(Vt), matTranspose(U));
  }
  // t = tgtC - R*srcC
  const RsrcC = matVec(R, srcC);
  const t = [
    tgtC[0] - RsrcC[0],
    tgtC[1] - RsrcC[1],
    tgtC[2] - RsrcC[2]
  ];
  return { R, t };
}


// ------------------------------------------------------
// 5) ERROR COMPUTATION: Distances to shape[0]
// ------------------------------------------------------
function computeErrors(refShape, allShapes) {
  // refShape = V x 3
  // allShapes = N x V x 3
  const N = allShapes.length;
  const V = refShape.length;
  const errors = new Array(N);
  for (let i = 0; i < N; i++) {
    errors[i] = new Array(V);
    for (let v = 0; v < V; v++) {
      errors[i][v] = euclideanDist(allShapes[i][v], refShape[v]);
    }
  }
  return errors;
}

function findGlobalRange(errors) {
  // errors is NxV
  let minVal = Infinity, maxVal = -Infinity;
  for (let i = 0; i < errors.length; i++) {
    for (let v = 0; v < errors[i].length; v++) {
      const val = errors[i][v];
      if (val < minVal) minVal = val;
      if (val > maxVal) maxVal = val;
    }
  }
  return { minVal, maxVal };
}


// ------------------------------------------------------
// 6) VTK SETUP + SCALAR COLOR LOOKUP
// ------------------------------------------------------
function setupVTKScene() {
  if (renderer) {
    return; // already set
  }
  const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
    rootContainer: document.getElementById('vtkContainer'),
    containerStyle: {
      width: '100%',
      height: '100%',
      position: 'relative',
      overflow: 'hidden'
    }
  });
  renderWindow = fullScreenRenderer.getRenderWindow();
  renderer = fullScreenRenderer.getRenderer();

  const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
  mapper.setColorModeToMapScalars();  // interpret scalars as lookups
  mapper.setScalarModeToUsePointData();
  mapper.setInterpolateScalarsBeforeMapping(true);

  vtkActor = vtk.Rendering.Core.vtkActor.newInstance();
  vtkActor.setMapper(mapper);
  renderer.addActor(vtkActor);
  renderer.resetCamera();
  renderWindow.render();
}

function createLookupTable(minVal, maxVal) {
  // Create a simple rainbow-like lookup table
  const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
  // For example, we map minVal => blue, mid => green, maxVal => red
  lut.addRGBPoint(minVal, 0.0, 0.0, 1.0);  // blue
  lut.addRGBPoint((minVal+maxVal)*0.5, 0.0, 1.0, 0.0); // green
  lut.addRGBPoint(maxVal, 1.0, 0.0, 0.0);  // red
  return lut;
}


// ------------------------------------------------------
// 7) RENDER SELECTED SHAPE WITH ERROR SCALARS
// ------------------------------------------------------
function updateDisplayedVariant(index) {
  if (!alignedShapes || !errorsArray || !faces) return;
  index = parseInt(index);
  if (index < 0 || index >= alignedShapes.length) return;

  const pointsArray = alignedShapes[index]; // V x 3
  const shapeErrors = errorsArray[index];   // V
  const nVerts = pointsArray.length;
  const nFaces = faces.length;

  // Convert points => vtkPoints
  const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
  vtkPoints.setNumberOfPoints(nVerts);
  for (let i = 0; i < nVerts; i++) {
    vtkPoints.setPoint(i, pointsArray[i][0], pointsArray[i][1], pointsArray[i][2]);
  }

  // Convert faces => cell array
  const polys = new Uint32Array(nFaces * 4);
  for (let f = 0; f < nFaces; f++) {
    const offset = f * 4;
    polys[offset]   = 3; // tri
    polys[offset+1] = faces[f][0];
    polys[offset+2] = faces[f][1];
    polys[offset+3] = faces[f][2];
  }

  // Create PolyData
  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
  polyData.setPoints(vtkPoints);
  polyData.getPolys().setData(polys);

  // Attach error scalars
  const scalarsData = new Float32Array(shapeErrors); // length V
  const scalars = vtk.Common.Core.vtkDataArray.newInstance({
    name: 'Error',
    values: scalarsData
  });
  polyData.getPointData().setScalars(scalars);

  // Setup mapper
  vtkActor.getMapper().setInputData(polyData);
  vtkActor.getMapper().setLookupTable(lookupTable);
  vtkActor.getMapper().setUseLookupTableScalarRange(true);

  renderer.resetCamera();
  renderWindow.render();
}


// ------------------------------------------------------
// HELPER MATH
// ------------------------------------------------------
function euclideanDist(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}

function matMul(A, B) {
  // A: 3x3, B: 3x3 => returns 3x3
  const out = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i=0; i<3; i++){
    for (let j=0; j<3; j++){
      out[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + A[i][2]*B[2][j];
    }
  }
  return out;
}
function matTranspose(M) {
  return [
    [M[0][0], M[1][0], M[2][0]],
    [M[0][1], M[1][1], M[2][1]],
    [M[0][2], M[1][2], M[2][2]]
  ];
}
function matVec(M, v) {
  // M: 3x3, v: [3]
  return [
    M[0][0]*v[0] + M[0][1]*v[1] + M[0][2]*v[2],
    M[1][0]*v[0] + M[1][1]*v[1] + M[1][2]*v[2],
    M[2][0]*v[0] + M[2][1]*v[1] + M[2][2]*v[2]
  ];
}
function det3(M) {
  return M[0][0]*(M[1][1]*M[2][2] - M[1][2]*M[2][1])
       - M[0][1]*(M[1][0]*M[2][2] - M[1][2]*M[2][0])
       + M[0][2]*(M[1][0]*M[2][1] - M[1][1]*M[2][0]);
}


// ------------------------------------------------------
// SVD HELPER (3x3) + Minimal Numeric Approach
// ------------------------------------------------------
function svd3(H) {
  // H is 3x3
  // We'll implement a small numeric SVD by eigen-decomposition of H^T H => V => U
  // Convert H to a typed array for convenience
  const A = new Float64Array([
    H[0][0], H[0][1], H[0][2],
    H[1][0], H[1][1], H[1][2],
    H[2][0], H[2][1], H[2][2]
  ]);
  return naiveSVD3(A);
}

/**
 * naiveSVD3(A) => { U, S, Vt }
 * A is 9 elements, row-major.
 * This function is for demonstration; real usage might use a numeric library.
 */
function naiveSVD3(A) {
  // A: row-major 3x3
  // 1) M = A^T * A => eigen decomposition => V => S => then U
  const A00 = A[0], A01 = A[1], A02 = A[2];
  const A10 = A[3], A11 = A[4], A12 = A[5];
  const A20 = A[6], A21 = A[7], A22 = A[8];

  // M = A^T * A
  const M = [
    [
      A00*A00 + A10*A10 + A20*A20,
      A00*A01 + A10*A11 + A20*A21,
      A00*A02 + A10*A12 + A20*A22
    ],
    [
      A01*A00 + A11*A10 + A21*A20,
      A01*A01 + A11*A11 + A21*A21,
      A01*A02 + A11*A12 + A21*A22
    ],
    [
      A02*A00 + A12*A10 + A22*A20,
      A02*A01 + A12*A11 + A22*A21,
      A02*A02 + A12*A12 + A22*A22
    ]
  ];

  // eigen-decompose M => V => diag(eigs) => S
  const { eigenvectors, eigenvalues } = eigenDecomp3(M);
  // sort by descending eigenvalue
  const sorted = [0,1,2].sort((i,j)=>eigenvalues[j]-eigenvalues[i]);
  const Svals = sorted.map(idx => Math.sqrt(Math.max(eigenvalues[idx], 1e-12)));

  // V = columns of eigenvectors in that sorted order => row-major
  const V = [[], [], []];
  for (let col = 0; col < 3; col++) {
    // place eigenvectors in columns
    V[0][col] = eigenvectors[0][sorted[col]];
    V[1][col] = eigenvectors[1][sorted[col]];
    V[2][col] = eigenvectors[2][sorted[col]];
  }

  // build Vt
  const Vt = matTranspose(V);

  // U = A * V * S^-1
  // We do A * (V / S)
  const invS = [1/Svals[0], 1/Svals[1], 1/Svals[2]];
  let U_ = new Array(9).fill(0);
  // (A * V) => 3x3 times 3x3
  for (let i=0; i<3; i++){
    for (let j=0; j<3; j++){
      let sum=0;
      for (let k=0; k<3; k++){
        sum += A[i*3+k]*V[k][j];
      }
      // then scale by 1/S[j]
      U_[i*3 + j] = sum*invS[j];
    }
  }
  // Convert U_ => 3x3
  const U = [
    [U_[0], U_[1], U_[2]],
    [U_[3], U_[4], U_[5]],
    [U_[6], U_[7], U_[8]]
  ];
  // done
  return {
    U,
    S: Svals,
    Vt
  };
}

/**
 * eigenDecomp3(M): naive eigen decomposition of a 3x3 real symmetric matrix.
 * returns { eigenvalues, eigenvectors }, each array of length 3
 */
function eigenDecomp3(M) {
  // For real, symmetric 3x3, we can do a naive Jacobi or direct approach.
  // For brevity, let's do a quick approximate method.
  // In practice, you'd use a numeric library.

  // Convert M to typed array
  let A = new Float64Array([
    M[0][0], M[0][1], M[0][2],
    M[1][0], M[1][1], M[1][2],
    M[2][0], M[2][1], M[2][2]
  ]);

  // We'll just do a naive jacobi approach
  const EPS = 1e-12;
  let V = new Float64Array([1,0,0, 0,1,0, 0,0,1]); // identity
  let maxIter=50;
  for (let iter=0; iter<maxIter; iter++){
    // find max off-diagonal
    let p=0,q=0;
    let maxVal=0;
    for(let r=0;r<3;r++){
      for(let c=r+1;c<3;c++){
        const val = Math.abs(A[r*3+c]);
        if(val>maxVal){ maxVal=val; p=r; q=c; }
      }
    }
    if(maxVal<EPS) break;
    const a_pp = A[p*3+p], a_qq = A[q*3+q], a_pq = A[p*3+q];
    const theta = 0.5*Math.atan2(2*a_pq, a_pp - a_qq);
    const c = Math.cos(theta), s = Math.sin(theta);
    // apply rotation in p,q plane to A
    // A' = R^T A R
    for(let k=0;k<3;k++){
      const apk = A[p*3+k], aqk = A[q*3+k];
      A[p*3+k] = c*apk - s*aqk;
      A[q*3+k] = s*apk + c*aqk;
    }
    for(let k=0;k<3;k++){
      const akp = A[k*3+p], akq = A[k*3+q];
      A[k*3+p] = c*akp - s*akq;
      A[k*3+q] = s*akp + c*akq;
    }
    // fix diag
    A[p*3+p] = c*c*a_pp -2*s*c*a_pq + s*s*a_qq;
    A[q*3+q] = s*s*a_pp +2*s*c*a_pq + c*c*a_qq;
    A[p*3+q] = 0; A[q*3+p] = 0;

    // update V
    for(let k=0;k<3;k++){
      const vkp = V[k*3+p], vkq = V[k*3+q];
      V[k*3+p] = c*vkp - s*vkq;
      V[k*3+q] = s*vkp + c*vkq;
    }
  }
  // diagonal of A are eigenvalues
  const eigenvalues = [ A[0], A[4], A[8] ];
  // V are columns = eigenvectors
  // we can repackage V into a 2D array
  const eigenvectors = [
    [V[0], V[3], V[6]],
    [V[1], V[4], V[7]],
    [V[2], V[5], V[8]],
  ];
  return { eigenvalues, eigenvectors };
}


// ------------------------------------------------------
// BUTTON / SLIDER HOOKS
// ------------------------------------------------------
document.getElementById('fetchDataBtn').onclick = fetchPCAData;
document.getElementById('sourceBtn').onclick = () => {
  selectingSource = true;
  selectingTarget = false;
  alert("Click any point in the scatter plot to set SOURCE.");
};
document.getElementById('targetBtn').onclick = () => {
  selectingTarget = true;
  selectingSource = false;
  alert("Click any point in the scatter plot to set TARGET.");
};
document.getElementById('computeBtn').onclick = computeInterpolation;

document.getElementById('variantSlider').oninput = function(e) {
  updateDisplayedVariant(e.target.value);
};
</script>

</body>
</html>
