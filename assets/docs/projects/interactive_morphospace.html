<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace (Zero-Out Other PCs, Single-Click)</title>

  <!-- 1) Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- 2) VTK.js for 3D rendering -->
  <script src="https://unpkg.com/vtk.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    #plotlyDiv {
      width: 600px;
      height: 480px;
      border: 1px solid #ccc;
      background: white;
      margin-bottom: 1em;
    }
    #variantSlider {
      width: 800px;
      margin: 10px 0 20px 0;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
    }
    .disabled {
      opacity: 0.4;
      pointer-events: none;
    }
    #infoBox {
      font-weight: bold;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>

<h1>Interactive Morphospace Viewer (Zero Other PCs)</h1>
<div class="controls">
  <button id="fetchDataBtn">Fetch PCA Data</button>

  <label for="xPCSelect">X PC:</label>
  <select id="xPCSelect"></select>

  <label for="yPCSelect">Y PC:</label>
  <select id="yPCSelect"></select>

  <button id="sourceBtn" class="disabled">Set Source Point</button>
  <button id="targetBtn" class="disabled">Set Target Point</button>
  <button id="computeBtn" class="disabled">Compute &amp; Interpolate</button>
</div>

<!-- Status box for current source & target -->
<div id="infoBox">
  Source: ( -- , -- )<br/>
  Target: ( -- , -- )
</div>

<div id="plotlyDiv"></div>
<input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />
<div id="vtkContainer"></div>

<script>
// ------------------------------------------------------
// GLOBALS
// ------------------------------------------------------
let pcaData = null;        // Nx15 from the server
let specimenIds = null;    // optional
let xPCIndex = 0;          // dimension used for X
let yPCIndex = 1;          // dimension used for Y

// For picking source/target
let selectingSource = false;
let selectingTarget = false;
let sourceCoord = null;    // [xVal, yVal] in the current PC plane
let targetCoord = null;    // [xVal, yVal]
let sourcePC = null;       // [15]
let targetPC = null;       // [15]

// The shapes returned by the server
let serverAlignedShapes = null;
let faces = null;
let errorsArray = null;
let globalErrorMin = 0;
let globalErrorMax = 1;

// VTK
let renderer = null;
let renderWindow = null;
let vtkActor = null;
let lookupTable = null;
let slider = null;

let plotDiv = null;
let originalTrace = null; // the main red scatter

// A small helper for the infoBox
function updateInfoBox() {
  const box = document.getElementById('infoBox');
  const sx = sourceCoord ? sourceCoord[0].toFixed(3) : '--';
  const sy = sourceCoord ? sourceCoord[1].toFixed(3) : '--';
  const tx = targetCoord ? targetCoord[0].toFixed(3) : '--';
  const ty = targetCoord ? targetCoord[1].toFixed(3) : '--';

  box.innerHTML = `Source: (${sx}, ${sy})<br/>Target: (${tx}, ${ty})`;
}

// ------------------------------------------------------
// UTILS
// ------------------------------------------------------
function enableButton(id, enable) {
  const btn = document.getElementById(id);
  if (enable) {
    btn.classList.remove("disabled");
  } else {
    btn.classList.add("disabled");
  }
}

// We'll zero out all 15 PCs except the 2 chosen
function zeroedPCArray() {
  return new Array(15).fill(0);
}

function updateComputeBtnState() {
  // only enable if both sourcePC + targetPC are set
  const canCompute = (sourcePC != null && targetPC != null);
  enableButton("computeBtn", canCompute);
}

// Clear any shapes in the VTK viewer if they've been displayed
function clearVTKScene() {
  if (renderer) {
    renderer.delete();
    renderWindow.delete();
    renderer = null;
    renderWindow = null;
    vtkActor = null;
    lookupTable = null;
  }
  slider = document.getElementById("variantSlider");
  slider.min = 0;
  slider.max = 0;
  slider.value = 0;
  serverAlignedShapes = null;
  faces = null;
  errorsArray = null;
}

// Clear the currently selected source/target from memory
function clearSourceTarget() {
  selectingSource = false;
  selectingTarget = false;
  sourceCoord = null;
  targetCoord = null;
  sourcePC = null;
  targetPC = null;
  // remove the line or special markers
  redrawPlot();
  updateComputeBtnState();
  updateInfoBox();
}

// ------------------------------------------------------
// 1) FETCH PCA DATA
// ------------------------------------------------------
async function fetchPCAData() {
  console.log("fetchPCAData() called...");
  try {
    const resp = await fetch("https://morphvq.net/get-initial", { method:'GET' });
    if(!resp.ok) {
      throw new Error(`Fetch error: ${resp.status} - ${resp.statusText}`);
    }
    const data = await resp.json();
    pcaData = data.components;
    specimenIds = data.specimen_ids;
    console.log("-> Fetched PCA data. shape:", pcaData.length, "x", pcaData[0].length);

    fillPCSelects();
    plotPCAScatter();

    // Now that we have data, let user pick source/target
    enableButton("sourceBtn", true);
    enableButton("targetBtn", true);

    console.log("-> End fetchPCAData() with success.");
  } catch(err) {
    alert("Error fetching PCA data: "+err);
    console.error(err);
  }
}


// ------------------------------------------------------
// 2) POPULATE SELECTS FOR X/Y PC
// ------------------------------------------------------
function fillPCSelects() {
  const xSel = document.getElementById('xPCSelect');
  const ySel = document.getElementById('yPCSelect');
  xSel.innerHTML = "";
  ySel.innerHTML = "";

  for(let i=1; i<=15; i++){
    const optX = document.createElement('option');
    optX.value = i.toString();
    optX.textContent = "PC"+i;
    xSel.appendChild(optX);

    const optY = document.createElement('option');
    optY.value = i.toString();
    optY.textContent = "PC"+i;
    ySel.appendChild(optY);
  }

  xSel.value = "1";  // PC1
  ySel.value = "2";  // PC2
  xPCIndex = 0;
  yPCIndex = 1;

  xSel.onchange = (e)=>{
    xPCIndex = parseInt(e.target.value)-1;
    handlePCChange();
  };
  ySel.onchange = (e)=>{
    yPCIndex = parseInt(e.target.value)-1;
    handlePCChange();
  };
}

function handlePCChange() {
  console.log("PC changed => clearing source/target + VTK + replot");
  clearSourceTarget();
  clearVTKScene();
  plotPCAScatter();
}


// ------------------------------------------------------
// 3) PLOT THE PCA SCATTER
// ------------------------------------------------------
function plotPCAScatter() {
  console.log("plotPCAScatter() start...");
  if(!pcaData) return;

  // We'll plot the red scatter using the chosen (xPCIndex,yPCIndex)
  const xVals = pcaData.map(row => row[xPCIndex]);
  const yVals = pcaData.map(row => row[yPCIndex]);

  originalTrace = {
    x: xVals,
    y: yVals,
    mode: 'markers',
    type: 'scatter',
    marker: { size: 6, color: 'rgba(255,0,0,0.6)' },
    name: 'All Points'
  };

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title: `PC${xPCIndex+1}` },
    yaxis: { title: `PC${yPCIndex+1}` },
    // We'll set dragmode to 'select' so a single click can set a point
    dragmode: 'select',
    clickmode: 'event',
  };

  plotDiv = document.getElementById('plotlyDiv');
  Plotly.newPlot(plotDiv, [originalTrace], layout);

  // We'll attach 'plotly_click' for single-click in the plot area
  plotDiv.on('plotly_click', onPlotlyClick);

  console.log("-> plotPCAScatter done.");
}

function onPlotlyClick(data) {
  // data.points[0].x, data.points[0].y => the clicked location in data coordinates
  if(!data || !data.points || !data.points[0]) return;
  const xVal = data.points[0].x;
  const yVal = data.points[0].y;

  console.log(`onPlotlyClick => x=${xVal}, y=${yVal}`);

  if(selectingSource) {
    selectingSource = false;
    sourceCoord = [xVal, yVal];
    sourcePC = zeroedPCArray();
    sourcePC[xPCIndex] = xVal;
    sourcePC[yPCIndex] = yVal;
    alert(`Source set => (x=${xVal.toFixed(3)}, y=${yVal.toFixed(3)})`);
  }
  else if(selectingTarget) {
    selectingTarget = false;
    targetCoord = [xVal, yVal];
    targetPC = zeroedPCArray();
    targetPC[xPCIndex] = xVal;
    targetPC[yPCIndex] = yVal;
    alert(`Target set => (x=${xVal.toFixed(3)}, y=${yVal.toFixed(3)})`);
  }

  redrawPlot();
  updateComputeBtnState();
  updateInfoBox();
}

function redrawPlot() {
  if(!plotDiv || !originalTrace) return;

  let data = [ originalTrace ];

  // source marker
  if(sourceCoord) {
    const sTrace = {
      x: [sourceCoord[0]],
      y: [sourceCoord[1]],
      mode: 'markers',
      type: 'scatter',
      marker: { size:10, color:'green', symbol:'star' },
      name: 'Source'
    };
    data.push(sTrace);
  }
  // target marker
  if(targetCoord) {
    const tTrace = {
      x: [targetCoord[0]],
      y: [targetCoord[1]],
      mode: 'markers',
      type: 'scatter',
      marker: { size:10, color:'blue', symbol:'star' },
      name: 'Target'
    };
    data.push(tTrace);
  }

  // line
  if(sourceCoord && targetCoord) {
    const lTrace = {
      x: [sourceCoord[0], targetCoord[0]],
      y: [sourceCoord[1], targetCoord[1]],
      mode: 'lines',
      type: 'scatter',
      line: { color:'gray', width:2, dash:'dash' },
      name: 'Interpolation'
    };
    data.push(lTrace);
  }

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title:`PC${xPCIndex+1}` },
    yaxis: { title:`PC${yPCIndex+1}` },
    dragmode:'select',
    clickmode:'event'
  };

  Plotly.react(plotDiv, data, layout);
}


// ------------------------------------------------------
// 4) SET SOURCE/TARGET
// ------------------------------------------------------
document.getElementById('sourceBtn').onclick = ()=>{
  if(!pcaData) return;
  selectingSource = true;
  selectingTarget = false;
  alert("Click in the plot to set SOURCE");
};

document.getElementById('targetBtn').onclick = ()=>{
  if(!pcaData) return;
  selectingTarget = true;
  selectingSource = false;
  alert("Click in the plot to set TARGET");
};


// ------------------------------------------------------
// 5) COMPUTE & INTERPOLATE
// ------------------------------------------------------
document.getElementById('computeBtn').onclick = computeInterpolation;

async function computeInterpolation() {
  if(!sourcePC || !targetPC) {
    alert("Need both source and target set!");
    return;
  }
  console.log("computeInterpolation() => zero-other-PC approach.");

  // Clear existing shapes if any
  clearVTKScene();

  const payload = {
    pc_scores: [ sourcePC, targetPC ]
  };
  console.log("-> POST /interpolate =>", payload);

  try {
    const resp = await fetch("https://morphvq.net/interpolate", {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(!resp.ok) throw new Error(`Interpolation error: ${resp.status} - ${resp.statusText}`);

    const result = await resp.json();
    serverAlignedShapes = result.shapes;
    faces = result.faces;
    console.log("-> /interpolate success. Received shapes len=", serverAlignedShapes.length, " faces len=", faces.length);

    computeErrorsAndSetupScene();
  }
  catch(err) {
    alert("Interpolation error: "+err.message);
    console.error(err);
  }
}


// ------------------------------------------------------
// 6) ONCE WE HAVE SHAPES => SETUP VTK & ERROR
// ------------------------------------------------------
function computeErrorsAndSetupScene() {
  if(!serverAlignedShapes || !serverAlignedShapes.length) return;

  const refShape = serverAlignedShapes[0];
  const nVerts = refShape.length;
  const N = serverAlignedShapes.length;
  errorsArray = new Array(N);

  let minVal = Infinity, maxVal=-Infinity;
  for(let i=0; i<N; i++){
    errorsArray[i] = new Array(nVerts);
    for(let v=0; v<nVerts; v++){
      const d = euclideanDist(serverAlignedShapes[i][v], refShape[v]);
      errorsArray[i][v] = d;
      if(d<minVal) minVal=d;
      if(d>maxVal) maxVal=d;
    }
  }
  globalErrorMin = minVal;
  globalErrorMax = maxVal;
  console.log("-> error range:",globalErrorMin,"..",globalErrorMax);

  // create or re-init VTK scene
  setupVTKScene();
  lookupTable = createLookupTable(globalErrorMin, globalErrorMax);

  // slider
  slider = document.getElementById('variantSlider');
  slider.min=0;
  slider.max=N-1;
  slider.value=0;
  updateDisplayedVariant(0);
}

function setupVTKScene() {
  if(renderer) return; // already done
  console.log("setupVTKScene() => new vtkFullScreenRenderWindow...");
  const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
    rootContainer: document.getElementById('vtkContainer'),
    containerStyle:{
      width:'100%', height:'100%', position:'relative', overflow:'hidden'
    }
  });
  renderWindow = fullScreenRenderer.getRenderWindow();
  renderer = fullScreenRenderer.getRenderer();

  const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
  mapper.setColorModeToMapScalars();
  mapper.setScalarModeToUsePointData();
  mapper.setInterpolateScalarsBeforeMapping(true);

  vtkActor = vtk.Rendering.Core.vtkActor.newInstance();
  vtkActor.setMapper(mapper);
  renderer.addActor(vtkActor);

  renderer.resetCamera();
  renderWindow.render();
  console.log("-> setupVTKScene done.");
}

function createLookupTable(minVal, maxVal) {
  const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
  lut.addRGBPoint(minVal, 0,0,1);
  lut.addRGBPoint( (minVal+maxVal)/2, 0,1,0 );
  lut.addRGBPoint(maxVal, 1,0,0);
  return lut;
}


// ------------------------------------------------------
// 7) RENDER SELECTED SHAPE
// ------------------------------------------------------
document.getElementById('variantSlider').oninput = (e)=>{
  updateDisplayedVariant(parseInt(e.target.value));
};

function updateDisplayedVariant(index) {
  if(!serverAlignedShapes || !errorsArray || !faces) return;
  if(index<0 || index>=serverAlignedShapes.length) return;

  const shape = serverAlignedShapes[index];
  const errs  = errorsArray[index];
  const nVerts = shape.length;
  const nFaces = faces.length;

  const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
  vtkPoints.setNumberOfPoints(nVerts);
  for(let i=0; i<nVerts; i++){
    vtkPoints.setPoint(i, shape[i][0], shape[i][1], shape[i][2]);
  }

  const polys = new Uint32Array(nFaces*4);
  for(let f=0; f<nFaces; f++){
    const off=f*4;
    polys[off] = 3;
    polys[off+1] = faces[f][0];
    polys[off+2] = faces[f][1];
    polys[off+3] = faces[f][2];
  }

  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
  polyData.setPoints(vtkPoints);
  polyData.getPolys().setData(polys);

  const scalarsData = new Float32Array(errs);
  const scalars = vtk.Common.Core.vtkDataArray.newInstance({
    name:'Error',
    values: scalarsData
  });
  polyData.getPointData().setScalars(scalars);

  const mapper = vtkActor.getMapper();
  mapper.setInputData(polyData);
  mapper.setLookupTable(lookupTable);
  mapper.setUseLookupTableScalarRange(true);

  renderer.resetCamera();
  renderWindow.render();
}

// ------------------------------------------------------
// MISC UTILS
// ------------------------------------------------------
function euclideanDist(a, b){
  const dx=a[0]-b[0], dy=a[1]-b[1], dz=a[2]-b[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}


// ------------------------------------------------------
// HOOKS
// ------------------------------------------------------
document.getElementById('fetchDataBtn').onclick = fetchPCAData;
</script>

</body>
</html>
