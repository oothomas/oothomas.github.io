<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace (Client-side Alignment & Error Coloring)</title>

  <!-- 1) Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- 2) VTK.js for 3D rendering -->
  <script src="https://unpkg.com/vtk.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    #plotlyDiv {
      width: 600px;
      height: 480px;
      border: 1px solid #ccc;
      background: white;
      margin-bottom: 1em;
    }
    #variantSlider {
      width: 800px;
      margin: 10px 0 20px 0;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
    }
  </style>
</head>
<body>

<h1>Interactive Morphospace Viewer</h1>
<p>
  This page allows you to:
</p>
<ol>
  <li>Select which PCs to plot on X/Y axes.</li>
  <li>Choose a source and target point from the scatter plot.</li>
  <li>Fetch and interpolate shapes from the server <b>(aligned on the server)</b>.</li>
  <li>Color the meshes by per-vertex <b>error</b> (distance from reference shape #0).</li>
  <li>Use the slider to step through the interpolated series.</li>
</ol>

<div class="controls">
  <button id="fetchDataBtn">Fetch PCA Data</button>

  <label for="xPCSelect">X PC:</label>
  <select id="xPCSelect"></select>

  <label for="yPCSelect">Y PC:</label>
  <select id="yPCSelect"></select>

  <button id="sourceBtn">Set Source Point</button>
  <button id="targetBtn">Set Target Point</button>
  <button id="computeBtn">Compute &amp; Interpolate</button>
</div>

<!-- The Plotly scatter plot -->
<div id="plotlyDiv"></div>

<!-- Slider to pick which shape variant to display -->
<input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />

<!-- VTK Container -->
<div id="vtkContainer"></div>

<script>
// ------------------------------------------------------
// GLOBALS
// ------------------------------------------------------
let pcaData = null;
let specimenIds = null;
let xPCIndex = 0;
let yPCIndex = 1;

let selectingSource = false;
let selectingTarget = false;
let sourcePoint = null;
let targetPoint = null;

// After interpolation
let serverAlignedShapes = null;  // NxVx3 (ALREADY aligned by the server)
let faces = null;                // Fx3
let errorsArray = null;          // NxV (distances from shape[0])
let globalErrorMin = 0;
let globalErrorMax = 1;

// VTK / Rendering
let renderer = null;
let renderWindow = null;
let vtkActor = null;
let lookupTable = null;
let slider = null;


// ------------------------------------------------------
// 1) FETCH PCA DATA
// ------------------------------------------------------
async function fetchPCAData() {
  console.log("fetchPCAData() called...");
  try {
    const resp = await fetch("https://morphvq.net/get-initial", { method: 'GET' });
    if (!resp.ok) {
      throw new Error(`Fetch error: ${resp.status} - ${resp.statusText}`);
    }
    const data = await resp.json();
    pcaData = data.components;
    specimenIds = data.specimen_ids;
    console.log("-> Fetched PCA data. shape:", pcaData.length, "x", pcaData[0].length);

    fillPCSelects();
    plotPCAScatter();
    console.log("-> End fetchPCAData() with success.");
  } catch (err) {
    alert("Error fetching PCA data: " + err);
    console.error(err);
  }
}


// ------------------------------------------------------
// 2) POPULATE <select> FOR X/Y PC (1..15) & HOOK CHANGES
// ------------------------------------------------------
function fillPCSelects() {
  console.log("fillPCSelects()...");
  const xSelect = document.getElementById('xPCSelect');
  const ySelect = document.getElementById('yPCSelect');

  xSelect.innerHTML = "";
  ySelect.innerHTML = "";

  for (let i = 1; i <= 15; i++) {
    const optionX = document.createElement('option');
    optionX.value = i.toString();
    optionX.textContent = "PC" + i;
    xSelect.appendChild(optionX);

    const optionY = document.createElement('option');
    optionY.value = i.toString();
    optionY.textContent = "PC" + i;
    ySelect.appendChild(optionY);
  }

  // Default to PC1 for X, PC2 for Y
  xSelect.value = "1";
  ySelect.value = "2";
  xPCIndex = 0;
  yPCIndex = 1;

  xSelect.onchange = function(e) {
    xPCIndex = parseInt(e.target.value) - 1;
    plotPCAScatter();
  };
  ySelect.onchange = function(e) {
    yPCIndex = parseInt(e.target.value) - 1;
    plotPCAScatter();
  };
  console.log("-> fillPCSelects done. Defaults: xPCIndex=0, yPCIndex=1");
}


// ------------------------------------------------------
// 3) PLOT THE PCA SCATTER (Plotly)
// ------------------------------------------------------
function plotPCAScatter() {
  console.log("plotPCAScatter() start...");
  if (!pcaData || pcaData.length === 0) {
    console.warn("No PCA data to plot or not fetched yet.");
    return;
  }

  // Reset selection
  sourcePoint = null;
  targetPoint = null;

  const xVals = pcaData.map(row => row[xPCIndex]);
  const yVals = pcaData.map(row => row[yPCIndex]);

  const trace = {
    x: xVals,
    y: yVals,
    mode: 'markers',
    type: 'scatter',
    marker: { size: 7, color: 'rgba(255,0,0,0.6)' }
  };

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title: `PC${xPCIndex+1}` },
    yaxis: { title: `PC${yPCIndex+1}` }
  };

  Plotly.newPlot('plotlyDiv', [trace], layout);

  // Attach click
  const plotDiv = document.getElementById('plotlyDiv');
  plotDiv.on('plotly_click', (clickData) => {
    if (clickData.points && clickData.points.length > 0) {
      const pt = clickData.points[0];
      const xVal = pt.x;
      const yVal = pt.y;
      if (selectingSource) {
        sourcePoint = [xVal, yVal];
        alert(`Source set: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
        console.log("Source set =>", sourcePoint);
        selectingSource = false;
      } else if (selectingTarget) {
        targetPoint = [xVal, yVal];
        alert(`Target set: (${xVal.toFixed(3)}, ${yVal.toFixed(3)})`);
        console.log("Target set =>", targetPoint);
        selectingTarget = false;
      }
    }
  });

  console.log("-> plotPCAScatter done. Points plotted:", xVals.length);
}


// ------------------------------------------------------
// 4) POST SOURCE/TARGET => GET ALIGNED SHAPES (FROM SERVER)
// ------------------------------------------------------
async function computeInterpolation() {
  console.log("computeInterpolation() called...");
  if (!sourcePoint || !targetPoint) {
    alert("Please pick both source and target points from the scatter plot!");
    return;
  }

  // only set these PC coords
  const pcScores = [
    new Array(15).fill(0),
    new Array(15).fill(0)
  ];
  pcScores[0][xPCIndex] = sourcePoint[0];
  pcScores[0][yPCIndex] = sourcePoint[1];
  pcScores[1][xPCIndex] = targetPoint[0];
  pcScores[1][yPCIndex] = targetPoint[1];

  const payload = { pc_scores: pcScores };
  console.log("-> computeInterpolation: will POST payload:", payload);

  try {
    const resp = await fetch("https://morphvq.net/interpolate", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!resp.ok) {
      throw new Error(`Interpolation error: ${resp.status} - ${resp.statusText}`);
    }
    const result = await resp.json();
    serverAlignedShapes = result.shapes; // NxVx3, aligned on server
    faces = result.faces;                // Fx3

    console.log("-> fetch success. Received shapes (already aligned) and faces.");
    console.log("   shapes length:", serverAlignedShapes.length,
                "   each shape has V=", serverAlignedShapes[0].length, "vertices");
    console.log("   faces length:", faces.length);

    // Compute error relative to shape #0
    computeErrorsAndSetupScene();

  } catch (err) {
    alert("Error computing interpolation: " + err.message);
    console.error(err);
  }
}

// No more alignment in the client. We'll just do error + display

function computeErrorsAndSetupScene() {
  console.log("computeErrorsAndSetupScene()");
  // 1) compute errors
  const refShape = serverAlignedShapes[0];
  const nVerts = refShape.length;
  const N = serverAlignedShapes.length;

  errorsArray = new Array(N);
  for (let i=0; i<N; i++) {
    errorsArray[i] = new Array(nVerts);
    for (let v=0; v<nVerts; v++){
      errorsArray[i][v] = euclideanDist(serverAlignedShapes[i][v], refShape[v]);
    }
  }

  // find global min/max
  let minVal = Infinity, maxVal = -Infinity;
  for (let i=0; i<N; i++){
    for (let v=0; v<nVerts; v++){
      const val = errorsArray[i][v];
      if (val<minVal) minVal=val;
      if (val>maxVal) maxVal=val;
    }
  }
  globalErrorMin = minVal;
  globalErrorMax = maxVal;
  console.log("-> error range:", globalErrorMin, "to", globalErrorMax);

  // 2) setup VTK scene if not already
  if (!renderer) {
    setupVTKScene();
  }

  // 3) create LUT
  lookupTable = createLookupTable(globalErrorMin, globalErrorMax);

  // 4) set slider, show shape #0
  slider = document.getElementById('variantSlider');
  slider.min = 0;
  slider.max = serverAlignedShapes.length - 1;
  slider.value = 0;
  updateDisplayedVariant(0);
}


// ------------------------------------------------------
// 5) VTK SCENE SETUP
// ------------------------------------------------------
function setupVTKScene() {
  console.log("setupVTKScene() ...");
  const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
    rootContainer: document.getElementById('vtkContainer'),
    containerStyle: {
      width: '100%',
      height: '100%',
      position: 'relative',
      overflow: 'hidden'
    }
  });
  renderWindow = fullScreenRenderer.getRenderWindow();
  renderer = fullScreenRenderer.getRenderer();

  const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
  mapper.setColorModeToMapScalars();
  mapper.setScalarModeToUsePointData();
  mapper.setInterpolateScalarsBeforeMapping(true);

  vtkActor = vtk.Rendering.Core.vtkActor.newInstance();
  vtkActor.setMapper(mapper);
  renderer.addActor(vtkActor);
  renderer.resetCamera();
  renderWindow.render();
  console.log("-> setupVTKScene done");
}

function createLookupTable(minVal, maxVal) {
  const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
  lut.addRGBPoint(minVal, 0, 0, 1);  // blue
  lut.addRGBPoint((minVal+maxVal)*0.5, 0, 1, 0); // green
  lut.addRGBPoint(maxVal, 1, 0, 0);  // red
  return lut;
}


// ------------------------------------------------------
// 6) RENDER SELECTED SHAPE
// ------------------------------------------------------
function updateDisplayedVariant(index) {
  index = parseInt(index);
  console.log(`updateDisplayedVariant(${index})...`);

  if (!serverAlignedShapes || !errorsArray || !faces) return;
  if (index<0 || index>=serverAlignedShapes.length) return;

  const pointsArray = serverAlignedShapes[index];  // Vx3
  const shapeErrors = errorsArray[index];          // V
  const nVerts = pointsArray.length;
  const nFaces = faces.length;

  // Build polydata
  const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
  vtkPoints.setNumberOfPoints(nVerts);
  for (let i=0; i<nVerts; i++){
    vtkPoints.setPoint(i, pointsArray[i][0], pointsArray[i][1], pointsArray[i][2]);
  }

  const polys = new Uint32Array(nFaces * 4);
  for (let f=0; f<nFaces; f++){
    const offset = f*4;
    polys[offset]   = 3;
    polys[offset+1] = faces[f][0];
    polys[offset+2] = faces[f][1];
    polys[offset+3] = faces[f][2];
  }

  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
  polyData.setPoints(vtkPoints);
  polyData.getPolys().setData(polys);

  const scalarsData = new Float32Array(shapeErrors);
  const scalars = vtk.Common.Core.vtkDataArray.newInstance({
    name: 'Error',
    values: scalarsData
  });
  polyData.getPointData().setScalars(scalars);

  const mapper = vtkActor.getMapper();
  mapper.setInputData(polyData);
  mapper.setLookupTable(lookupTable);
  mapper.setUseLookupTableScalarRange(true);

  renderer.resetCamera();
  renderWindow.render();
  console.log("-> updateDisplayedVariant done.");
}


// ------------------------------------------------------
// HELPER
// ------------------------------------------------------
function euclideanDist(a, b) {
  const dx = a[0]-b[0];
  const dy = a[1]-b[1];
  const dz = a[2]-b[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}


// ------------------------------------------------------
// BUTTON HOOKS
// ------------------------------------------------------
document.getElementById('fetchDataBtn').onclick = fetchPCAData;
document.getElementById('sourceBtn').onclick = () => {
  selectingSource = true;
  selectingTarget = false;
  alert("Click any point in the scatter plot to set SOURCE.");
};
document.getElementById('targetBtn').onclick = () => {
  selectingTarget = true;
  selectingSource = false;
  alert("Click any point in the scatter plot to set TARGET.");
};
document.getElementById('computeBtn').onclick = computeInterpolation;

document.getElementById('variantSlider').oninput = (e) => {
  updateDisplayedVariant(e.target.value);
};
</script>

</body>
</html>
