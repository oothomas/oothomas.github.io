<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Morphospace (Zero-Out Other PCs)</title>

  <!-- 1) Plotly for 2D scatter plot -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- 2) VTK.js for 3D rendering -->
  <script src="https://unpkg.com/vtk.js"></script>

  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    #plotlyDiv {
      width: 600px;
      height: 480px;
      border: 1px solid #ccc;
      background: white;
      margin-bottom: 1em;
      position: relative;
    }
    #variantSlider {
      width: 800px;
      margin: 10px 0 20px 0;
    }
    #vtkContainer {
      width: 800px;
      height: 600px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
    }
    .disabled {
      opacity: 0.4;
      pointer-events: none;
    }
  </style>
</head>
<body>

<h1>Interactive Morphospace Viewer (Zero the Other PCs)</h1>
<p>
  This page allows you to:
</p>
<ol>
  <li>Fetch PCA data for 15 PCs.</li>
  <li>Select which PCs to plot on X/Y axes (only two visible at once).</li>
  <li>Set a source point (green) and target point (blue) by clicking <em>anywhere</em> in the plot.</li>
  <li>Those two PC coordinates are placed into their respective PC dimension, while the other 13 PCs are zeroed out.</li>
  <li>Compute & Interpolate sends <code>[[sourcePC...],[targetPC...]]</code> to the server, receiving aligned shapes.</li>
  <li>Visualize the shapes with an error colormap vs. shape #0.</li>
</ol>

<div class="controls">
  <button id="fetchDataBtn">Fetch PCA Data</button>

  <label for="xPCSelect">X PC:</label>
  <select id="xPCSelect"></select>

  <label for="yPCSelect">Y PC:</label>
  <select id="yPCSelect"></select>

  <button id="sourceBtn" class="disabled">Set Source Point</button>
  <button id="targetBtn" class="disabled">Set Target Point</button>
  <button id="computeBtn" class="disabled">Compute &amp; Interpolate</button>
</div>

<div id="plotlyDiv"></div>
<input type="range" id="variantSlider" min="0" max="0" value="0" step="1" />
<div id="vtkContainer"></div>

<script>
// ------------------------------------------------------
// GLOBALS
// ------------------------------------------------------
let pcaData = null;        // Nx15 from the server
let specimenIds = null;    // optional
let xPCIndex = 0;          // dimension used for X
let yPCIndex = 1;          // dimension used for Y

// For picking source/target
let selectingSource = false;
let selectingTarget = false;
let sourceCoord = null;    // [xVal, yVal] in the current PC plane
let targetCoord = null;    // same
let sourcePC = null;       // [15] (xPCIndex = xVal, yPCIndex = yVal, rest=0)
let targetPC = null;       // [15]

// The shapes returned by the server
let serverAlignedShapes = null;
let faces = null;
let errorsArray = null;
let globalErrorMin = 0;
let globalErrorMax = 1;

// VTK
let renderer = null;
let renderWindow = null;
let vtkActor = null;
let lookupTable = null;
let slider = null;

// We'll keep track of the original red scatter for reference
let originalTrace = null;
let plotDiv = null;

// ------------------------------------------------------
// UTILS
// ------------------------------------------------------
function enableButton(id, enable) {
  const btn = document.getElementById(id);
  if (enable) {
    btn.classList.remove("disabled");
  } else {
    btn.classList.add("disabled");
  }
}

function zeroedPCArray() {
  return new Array(15).fill(0);
}

// For showing/hiding the compute button
function updateComputeBtnState() {
  // only enabled if sourcePC + targetPC are set
  const canCompute = (sourcePC!==null && targetPC!==null);
  enableButton("computeBtn", canCompute);
}

// Clear any shapes in the VTK viewer if they've been displayed
function clearVTKScene() {
  if (renderer) {
    renderer.delete();
    renderWindow.delete();
    renderer = null;
    renderWindow = null;
    vtkActor = null;
    lookupTable = null;
  }
  slider = document.getElementById("variantSlider");
  slider.min = 0;
  slider.max = 0;
  slider.value = 0;
  serverAlignedShapes = null;
  faces = null;
  errorsArray = null;
}

// Clear the currently selected source/target from memory
function clearSourceTarget() {
  selectingSource = false;
  selectingTarget = false;
  sourceCoord = null;
  targetCoord = null;
  sourcePC = null;
  targetPC = null;
  // remove the line or special markers
  redrawPlot();
  // disable compute button
  updateComputeBtnState();
}

// ------------------------------------------------------
// 1) FETCH PCA DATA
// ------------------------------------------------------
async function fetchPCAData() {
  console.log("fetchPCAData() called...");
  try {
    const resp = await fetch("https://morphvq.net/get-initial", { method:'GET' });
    if(!resp.ok) {
      throw new Error(`Fetch error: ${resp.status} - ${resp.statusText}`);
    }
    const data = await resp.json();
    pcaData = data.components;
    specimenIds = data.specimen_ids;
    console.log("-> Fetched PCA data. shape:", pcaData.length, "x", pcaData[0].length);

    fillPCSelects();
    plotPCAScatter();

    // Now that we have data, let user pick source/target
    enableButton("sourceBtn", true);
    enableButton("targetBtn", true);

    console.log("-> End fetchPCAData() with success.");
  } catch(err) {
    alert("Error fetching PCA data: "+err);
    console.error(err);
  }
}


// ------------------------------------------------------
// 2) POPULATE SELECTS FOR X/Y PC
// ------------------------------------------------------
function fillPCSelects() {
  const xSel = document.getElementById('xPCSelect');
  const ySel = document.getElementById('yPCSelect');
  xSel.innerHTML = "";
  ySel.innerHTML = "";

  for(let i=1; i<=15; i++){
    const optX = document.createElement('option');
    optX.value = i.toString();
    optX.textContent = "PC"+i;
    xSel.appendChild(optX);

    const optY = document.createElement('option');
    optY.value = i.toString();
    optY.textContent = "PC"+i;
    ySel.appendChild(optY);
  }

  xSel.value = "1";  // PC1
  ySel.value = "2";  // PC2
  xPCIndex = 0;
  yPCIndex = 1;

  xSel.onchange = (e)=>{
    xPCIndex = parseInt(e.target.value)-1;
    handlePCChange();
  };
  ySel.onchange = (e)=>{
    yPCIndex = parseInt(e.target.value)-1;
    handlePCChange();
  };
}

function handlePCChange() {
  console.log("PC changed => clearing source/target + VTK + replot");
  clearSourceTarget();
  clearVTKScene();
  plotPCAScatter();
}

// ------------------------------------------------------
// 3) PLOT THE PCA SCATTER
// ------------------------------------------------------
function plotPCAScatter() {
  console.log("plotPCAScatter() start...");
  if(!pcaData) return;

  // We'll plot the red scatter using the chosen (xPCIndex,yPCIndex)
  const xVals = pcaData.map(row => row[xPCIndex]);
  const yVals = pcaData.map(row => row[yPCIndex]);

  originalTrace = {
    x: xVals,
    y: yVals,
    mode: 'markers',
    type: 'scatter',
    marker: { size: 6, color: 'rgba(255,0,0,0.6)' },
    name: 'All Points'
  };

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title: `PC${xPCIndex+1}` },
    yaxis: { title: `PC${yPCIndex+1}` },
    dragmode: 'pan',    // so user can pan
    clickmode: 'event', // so we get all click events
  };

  plotDiv = document.getElementById('plotlyDiv');
  Plotly.newPlot(plotDiv, [originalTrace], layout);

  // We'll attach a "plotly_click" event for data points, but also attach a generic
  // click listener for the entire div so we can get x/y anywhere in the plane.
  //
  // Method: We'll do 'plotly_relayout' hack to get x/y from the mouse event
  // whenever user clicks in the main plot area.
  // This is a known workaround since Plotly doesn't provide a direct "click anywhere" by default.

  plotDiv.on('mousedown', onPlotlyDivMouseDown);

  console.log("-> plotPCAScatter done.");
}

function onPlotlyDivMouseDown(ev) {
  // We only care if we are picking source or target
  if(!selectingSource && !selectingTarget) return;

  // The event's x,y are in pixel coords. We have to invert them to data coords.
  // We can use Plotly.d3's built-in methods or do a direct approach:
  const rect = ev.target.getBoundingClientRect();
  const offsetX = ev.clientX - rect.left;
  const offsetY = ev.clientY - rect.top;

  // We'll get the plot's current axis ranges
  const gd = plotDiv; // 'gd' for graph div
  const bb = gd._fullLayout._size; // bounding box of the plotting area in px
  const xRange = gd._fullLayout.xaxis.range;
  const yRange = gd._fullLayout.yaxis.range;

  // figure out how offsetX,offsetY map onto xRange,yRange
  // xRange is [xMin, xMax], yRange is [yMin, yMax] if not reversed
  // but if the y-axis is top->bottom, we invert.

  const plotWidthPx  = bb.w;
  const plotHeightPx = bb.h;
  const plotLeftPx   = bb.l;
  const plotTopPx    = bb.t;  // distance from top
  // The main "plotting area" is from (bb.l, bb.t) to (bb.l+bb.w, bb.t+bb.h)
  // We'll see if the click is inside that region:
  const pxInsideX = offsetX - plotLeftPx; // in [0..plotWidthPx] if inside
  const pxInsideY = offsetY - plotTopPx;  // in [0..plotHeightPx] if inside

  if(pxInsideX<0 || pxInsideX>plotWidthPx || pxInsideY<0 || pxInsideY>plotHeightPx) {
    // user clicked outside the actual plot area
    return;
  }

  const xMin = xRange[0], xMax = xRange[1];
  const yMin = yRange[0], yMax = yRange[1];

  // convert px to data
  // xData = xMin + fraction*(xMax - xMin)
  const fracX = pxInsideX/plotWidthPx;
  let xVal = xMin + fracX*(xMax - xMin);

  // For y, note that by default plotly's y is bottom->top.
  // So we do 1 - pxInsideY/plotHeight for fraction
  const fracY = 1 - (pxInsideY/plotHeightPx);
  let yVal = yMin + fracY*(yMax - yMin);

  console.log("User clicked pxInsideX=", pxInsideX, "pxInsideY=", pxInsideY,
              " => (xVal,yVal)=(",xVal,",",yVal,")" );

  if(selectingSource) {
    selectingSource = false;
    sourceCoord = [xVal, yVal];
    sourcePC = zeroedPCArray();
    sourcePC[xPCIndex] = xVal;
    sourcePC[yPCIndex] = yVal;
    alert(`Source set => (x=${xVal.toFixed(3)}, y=${yVal.toFixed(3)})`);
  }
  else if(selectingTarget) {
    selectingTarget = false;
    targetCoord = [xVal, yVal];
    targetPC = zeroedPCArray();
    targetPC[xPCIndex] = xVal;
    targetPC[yPCIndex] = yVal;
    alert(`Target set => (x=${xVal.toFixed(3)}, y=${yVal.toFixed(3)})`);
  }

  redrawPlot();
  updateComputeBtnState();
}

function redrawPlot() {
  // We'll build an array of traces: the original red scatter + optional source + optional target + optional line
  if(!plotDiv || !originalTrace) return;

  let data = [ originalTrace ];

  // source marker
  if(sourceCoord) {
    const sTrace = {
      x: [sourceCoord[0]],
      y: [sourceCoord[1]],
      mode: 'markers',
      type: 'scatter',
      marker: { size:10, color:'green', symbol:'star' },
      name: 'Source'
    };
    data.push(sTrace);
  }
  // target marker
  if(targetCoord) {
    const tTrace = {
      x: [targetCoord[0]],
      y: [targetCoord[1]],
      mode: 'markers',
      type: 'scatter',
      marker: { size:10, color:'blue', symbol:'star' },
      name: 'Target'
    };
    data.push(tTrace);
  }

  // line
  if(sourceCoord && targetCoord) {
    const lTrace = {
      x: [sourceCoord[0], targetCoord[0]],
      y: [sourceCoord[1], targetCoord[1]],
      mode: 'lines',
      type: 'scatter',
      line: { color:'gray', width:2, dash:'dash' },
      name: 'Interpolation'
    };
    data.push(lTrace);
  }

  const layout = {
    title: `PCA Morphospace (PC${xPCIndex+1} vs PC${yPCIndex+1})`,
    xaxis: { title:`PC${xPCIndex+1}` },
    yaxis: { title:`PC${yPCIndex+1}` },
    dragmode:'pan',
    clickmode:'event',
  };

  Plotly.react(plotDiv, data, layout);
}


// ------------------------------------------------------
// 4) SET SOURCE/TARGET
// ------------------------------------------------------
document.getElementById('sourceBtn').onclick = ()=>{
  if(!pcaData) return;
  selectingSource = true;
  selectingTarget = false;
  alert("Click anywhere in the plot to set SOURCE");
};

document.getElementById('targetBtn').onclick = ()=>{
  if(!pcaData) return;
  selectingTarget = true;
  selectingSource = false;
  alert("Click anywhere in the plot to set TARGET");
};


// ------------------------------------------------------
// 5) COMPUTE & INTERPOLATE
// ------------------------------------------------------
document.getElementById('computeBtn').onclick = computeInterpolation;

async function computeInterpolation() {
  if(!sourcePC || !targetPC) {
    alert("Need both source and target set!");
    return;
  }
  console.log("computeInterpolation() => zero-other-PC approach.");

  // Clear existing shapes if any
  clearVTKScene();

  const payload = {
    pc_scores: [ sourcePC, targetPC ]
  };
  console.log("-> POST /interpolate =>", payload);

  try {
    const resp = await fetch("https://morphvq.net/interpolate", {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(!resp.ok) throw new Error(`Interpolation error: ${resp.status} - ${resp.statusText}`);

    const result = await resp.json();
    serverAlignedShapes = result.shapes;
    faces = result.faces;
    console.log("-> /interpolate success. Received shapes len=", serverAlignedShapes.length, " faces len=", faces.length);

    computeErrorsAndSetupScene();
  }
  catch(err) {
    alert("Interpolation error: "+err.message);
    console.error(err);
  }
}


// ------------------------------------------------------
// 6) ONCE WE HAVE SHAPES => SETUP VTK & ERROR
// ------------------------------------------------------
function computeErrorsAndSetupScene() {
  if(!serverAlignedShapes || !serverAlignedShapes.length) return;

  const refShape = serverAlignedShapes[0];
  const nVerts = refShape.length;
  const N = serverAlignedShapes.length;
  errorsArray = new Array(N);

  let minVal = Infinity, maxVal=-Infinity;
  for(let i=0; i<N; i++){
    errorsArray[i] = new Array(nVerts);
    for(let v=0; v<nVerts; v++){
      const d = euclideanDist(serverAlignedShapes[i][v], refShape[v]);
      errorsArray[i][v] = d;
      if(d<minVal) minVal=d;
      if(d>maxVal) maxVal=d;
    }
  }
  globalErrorMin = minVal;
  globalErrorMax = maxVal;
  console.log("-> error range:",globalErrorMin,"..",globalErrorMax);

  // create or re-init VTK scene
  setupVTKScene();
  lookupTable = createLookupTable(globalErrorMin, globalErrorMax);

  // slider
  slider = document.getElementById('variantSlider');
  slider.min=0;
  slider.max=N-1;
  slider.value=0;
  updateDisplayedVariant(0);
}

function setupVTKScene() {
  if(renderer) return; // already done
  console.log("setupVTKScene() => new vtkFullScreenRenderWindow...");
  const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
    rootContainer: document.getElementById('vtkContainer'),
    containerStyle:{
      width:'100%', height:'100%', position:'relative', overflow:'hidden'
    }
  });
  renderWindow = fullScreenRenderer.getRenderWindow();
  renderer = fullScreenRenderer.getRenderer();

  const mapper = vtk.Rendering.Core.vtkMapper.newInstance();
  mapper.setColorModeToMapScalars();
  mapper.setScalarModeToUsePointData();
  mapper.setInterpolateScalarsBeforeMapping(true);

  vtkActor = vtk.Rendering.Core.vtkActor.newInstance();
  vtkActor.setMapper(mapper);
  renderer.addActor(vtkActor);

  renderer.resetCamera();
  renderWindow.render();
  console.log("-> setupVTKScene done.");
}

function createLookupTable(minVal, maxVal) {
  const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
  lut.addRGBPoint(minVal, 0,0,1);
  lut.addRGBPoint( (minVal+maxVal)/2, 0,1,0 );
  lut.addRGBPoint(maxVal, 1,0,0);
  return lut;
}


// ------------------------------------------------------
// 7) RENDER SELECTED SHAPE
// ------------------------------------------------------
document.getElementById('variantSlider').oninput = (e)=>{
  updateDisplayedVariant(parseInt(e.target.value));
};

function updateDisplayedVariant(index) {
  if(!serverAlignedShapes || !errorsArray || !faces) return;
  if(index<0 || index>=serverAlignedShapes.length) return;

  const shape = serverAlignedShapes[index];
  const errs  = errorsArray[index];
  const nVerts = shape.length;
  const nFaces = faces.length;

  const vtkPoints = vtk.Common.Core.vtkPoints.newInstance();
  vtkPoints.setNumberOfPoints(nVerts);
  for(let i=0; i<nVerts; i++){
    vtkPoints.setPoint(i, shape[i][0], shape[i][1], shape[i][2]);
  }

  const polys = new Uint32Array(nFaces*4);
  for(let f=0; f<nFaces; f++){
    const off=f*4;
    polys[off] = 3;
    polys[off+1] = faces[f][0];
    polys[off+2] = faces[f][1];
    polys[off+3] = faces[f][2];
  }

  const polyData = vtk.Common.DataModel.vtkPolyData.newInstance();
  polyData.setPoints(vtkPoints);
  polyData.getPolys().setData(polys);

  const scalarsData = new Float32Array(errs);
  const scalars = vtk.Common.Core.vtkDataArray.newInstance({
    name:'Error',
    values: scalarsData
  });
  polyData.getPointData().setScalars(scalars);

  const mapper = vtkActor.getMapper();
  mapper.setInputData(polyData);
  mapper.setLookupTable(lookupTable);
  mapper.setUseLookupTableScalarRange(true);

  renderer.resetCamera();
  renderWindow.render();
}

// ------------------------------------------------------
// MISC UTILS
// ------------------------------------------------------
function euclideanDist(a, b){
  const dx=a[0]-b[0], dy=a[1]-b[1], dz=a[2]-b[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}


// ------------------------------------------------------
// HOOKS
// ------------------------------------------------------
document.getElementById('fetchDataBtn').onclick = fetchPCAData;
</script>

</body>
</html>
