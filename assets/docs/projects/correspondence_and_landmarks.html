<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VTK.js: 3 Random Farthest Points + T12 Mapping</title>
  <script src="https://unpkg.com/vtk.js@25.15.2/vtk.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
      color: #333;
    }
    h1 {
      text-align: center;
    }
    #mainContainer {
      max-width: 1200px;
      margin: 0 auto;
    }
    .vtkContainer {
      width: 100%;
      height: 480px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
      position: relative;
    }
    #mainFlex {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 1em;
    }
    .flexItem {
      flex: 1 1 calc(50% - 10px);
      box-sizing: border-box;
      min-width: 0;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,255,255,0.6);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      color: #333;
    }
    #spinnerText {
      background: #fff;
      padding: 20px;
      border: 2px solid #444;
      border-radius: 5px;
    }
    #infoBox {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .controls {
      margin-bottom: 1em;
      text-align: center;
    }
  </style>
</head>
<body>
<h1>VTK.js: 3 Random Farthest Points + T12 Mapping</h1>

<div id="mainContainer">
  <div class="controls">
    <button onclick="initViewers()">Initialize</button>
    <button id="farthestBtn" onclick="placeFarthestPoints()" disabled>Place 3 Farthest Points</button>
  </div>
  <div id="infoBox">No data loaded yet.</div>
  <div id="spinner">
    <div id="spinnerText">Loading...</div>
  </div>

  <div id="mainFlex">
    <div class="flexItem">
      <div id="vtkContainerLeft" class="vtkContainer"></div>
    </div>
    <div class="flexItem">
      <div id="vtkContainerRight" class="vtkContainer"></div>
    </div>
  </div>
</div>

<script>
// -------------------- GLOBALS --------------------
let leftView, rightView;
let rendererLeft, rendererRight, renderWindowLeft, renderWindowRight;
let meshActorLeft, meshActorRight;
let polyDataLeft = null, polyDataRight = null; 
let vertexMapping = null;  // T12 from JSON => mesh1->mesh2
let glyphActorsLeft = [];  // We'll store the 3 spheres for mesh1
let glyphActorsRight = []; // We'll store the 3 spheres for mesh2

// Show/hide spinner
function showSpinner(flag) {
  document.getElementById("spinner").style.display = flag ? "flex" : "none";
}

// Build polydata
function buildPolyData(verts, faces, colors) {
  const nVerts = verts.length;
  const nFaces = faces.length;

  const flatVerts = new Float32Array(nVerts*3);
  for(let i=0; i<nVerts; i++){
    flatVerts[3*i]   = verts[i][0];
    flatVerts[3*i+1] = verts[i][1];
    flatVerts[3*i+2] = verts[i][2];
  }
  const pts = vtk.Common.Core.vtkPoints.newInstance();
  pts.setData(flatVerts,3);

  const faceArr = new Uint32Array(nFaces*4);
  for(let i=0; i<nFaces; i++){
    faceArr[4*i+0] = 3; // triangle
    faceArr[4*i+1] = faces[i][0];
    faceArr[4*i+2] = faces[i][1];
    faceArr[4*i+3] = faces[i][2];
  }

  const poly = vtk.Common.DataModel.vtkPolyData.newInstance();
  poly.setPoints(pts);
  poly.getPolys().setData(faceArr);

  const cArr = vtk.Common.Core.vtkDataArray.newInstance({
    name:"Colors",
    values:new Uint8Array(colors.flat()),
    numberOfComponents:3,
    dataType:"Uint8Array",
  });
  poly.getPointData().setScalars(cArr);
  return poly;
}

// Distance helper
function euclidianDistSq(x1,y1,z1, x2,y2,z2){
  const dx=x2-x1, dy=y2-y1, dz=z2-z1;
  return dx*dx + dy*dy + dz*dz;
}

// pickFarthest3
// 1) pick v0 randomly
// 2) pick v1 farthest from v0
// 3) pick v2 farthest from both v0 & v1
function pickFarthest3(poly) {
  const n = poly.getPoints().getNumberOfPoints();
  if(n<3) {
    console.warn("Not enough vertices to pick 3 points!");
    return [0,0,0];
  }
  // v0 => random
  const v0 = Math.floor(Math.random()*n);

  // find v1 => farthest from v0
  let bestDist= -1, v1=0;
  const tmp0 = [0,0,0];
  poly.getPoints().getPoint(v0, tmp0);
  const p0x=tmp0[0], p0y=tmp0[1], p0z=tmp0[2];
  for(let i=0; i<n; i++){
    poly.getPoints().getPoint(i, tmp0);
    const dsq=euclidianDistSq(p0x,p0y,p0z, tmp0[0],tmp0[1],tmp0[2]);
    if(dsq>bestDist){
      bestDist=dsq;
      v1=i;
    }
  }

  // find v2 => farthest from either v0 or v1
  // i.e. pick the vertex that has the largest minimal distance
  // to the set {v0,v1}
  const tmp1=[0,0,0];
  poly.getPoints().getPoint(v1, tmp1);
  const p1x=tmp1[0], p1y=tmp1[1], p1z=tmp1[2];
  bestDist=-1; 
  let v2=0;
  for(let i=0; i<n; i++){
    poly.getPoints().getPoint(i, tmp0);
    const d0=euclidianDistSq(p0x,p0y,p0z, tmp0[0],tmp0[1],tmp0[2]);
    const d1=euclidianDistSq(p1x,p1y,p1z, tmp0[0],tmp0[1],tmp0[2]);
    // minimal distance to either v0 or v1
    const minDist = Math.min(d0, d1);
    if(minDist>bestDist){
      bestDist=minDist;
      v2=i;
    }
  }

  return [v0, v1, v2];
}

// MAIN INIT
async function initViewers(){
  console.log("initViewers() called");
  showSpinner(true);

  try{
    // A) Left viewer
    leftView = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById("vtkContainerLeft"),
      background:[0.2,0.2,0.2],
    });
    rendererLeft= leftView.getRenderer();
    renderWindowLeft= leftView.getRenderWindow();

    // B) Right viewer
    rightView= vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById("vtkContainerRight"),
      background:[0.2,0.2,0.2],
    });
    rendererRight= rightView.getRenderer();
    renderWindowRight= rightView.getRenderWindow();

    // Share camera
    rendererRight.setActiveCamera(rendererLeft.getActiveCamera());

    // Sync
    const syncRenders = ()=>{
      renderWindowLeft.render();
      renderWindowRight.render();
    };
    renderWindowLeft.getInteractor().onStartAnimation(syncRenders);
    renderWindowLeft.getInteractor().onEndAnimation(syncRenders);
    renderWindowRight.getInteractor().onStartAnimation(syncRenders);
    renderWindowRight.getInteractor().onEndAnimation(syncRenders);

    // C) Mappers / Actors
    const mapperLeft = vtk.Rendering.Core.vtkMapper.newInstance();
    meshActorLeft= vtk.Rendering.Core.vtkActor.newInstance();
    meshActorLeft.setMapper(mapperLeft);

    const mapperRight= vtk.Rendering.Core.vtkMapper.newInstance();
    meshActorRight= vtk.Rendering.Core.vtkActor.newInstance();
    meshActorRight.setMapper(mapperRight);

    // surface mode, pickable
    meshActorLeft.getProperty().setRepresentationToSurface();
    meshActorLeft.getProperty().setBackfaceCulling(false);
    meshActorLeft.getProperty().setFrontfaceCulling(false);
    meshActorLeft.setPickable(true);

    meshActorRight.getProperty().setRepresentationToSurface();
    meshActorRight.getProperty().setBackfaceCulling(false);
    meshActorRight.getProperty().setFrontfaceCulling(false);
    meshActorRight.setPickable(true);

    // D) fetch JSON
    const url="https://oothomas.github.io/assets/data/mesh_data_with_colors.json";
    console.log("Fetching JSON from:", url);
    const resp= await fetch(url);
    if(!resp.ok){
      throw new Error("HTTP error: "+resp.status);
    }
    const data=await resp.json();

    // E) T12 array in data.vertexMapping
    vertexMapping= data.vertexMapping; 
    if(!vertexMapping){
      console.warn("No vertexMapping in JSON => cannot map from mesh1->mesh2!");
    }

    // F) build mesh1, mesh2
    polyDataLeft= buildPolyData(
      data.mesh1.vertices, data.mesh1.faces, data.mesh1.colors
    );
    polyDataRight= buildPolyData(
      data.mesh2.vertices, data.mesh2.faces, data.mesh2.colors
    );

    // G) set up mappers
    mapperLeft.setInputData(polyDataLeft);
    mapperLeft.setColorModeToDirectScalars();
    mapperLeft.setScalarModeToUsePointData();
    mapperLeft.setInterpolateScalarsBeforeMapping(true);

    mapperRight.setInputData(polyDataRight);
    mapperRight.setColorModeToDirectScalars();
    mapperRight.setScalarModeToUsePointData();
    mapperRight.setInterpolateScalarsBeforeMapping(true);

    // add actors
    rendererLeft.addActor(meshActorLeft);
    rendererRight.addActor(meshActorRight);

    rendererLeft.resetCamera();
    rendererRight.resetCamera();
    renderWindowLeft.render();
    renderWindowRight.render();

    document.getElementById("infoBox").textContent=
      "Meshes + T12 loaded. Click 'Place 3 Farthest Points'!";
    document.getElementById("farthestBtn").disabled=false;
    console.log("Done init, ready to place points!");
  }
  catch(err){
    console.error("init error:", err);
    alert("Error: "+err);
  }
  finally{
    showSpinner(false);
  }
}

// place 3 farthest points
function placeFarthestPoints(){
  console.log("Placing 3 random farthest points on Mesh1 + corresponding on Mesh2...");

  // 1) remove old glyphs
  for(let actor of glyphActorsLeft) {
    rendererLeft.removeActor(actor);
  }
  glyphActorsLeft=[];
  for(let actor of glyphActorsRight){
    rendererRight.removeActor(actor);
  }
  glyphActorsRight=[];

  // 2) pick the 3 farthest vertex indices in mesh1
  if(!polyDataLeft){
    console.warn("No polyDataLeft loaded!");
    return;
  }
  const triple = pickFarthest3(polyDataLeft);
  console.log("Indices on mesh1 =>", triple);

  // colors for the 3 points => [ Red, Green, Blue ]
  const colorArray = [
    [1,0,0],  // red
    [0,1,0],  // green
    [0,0,1],  // blue
  ];

  // 3) For each of the 3 points in mesh1, place a sphere
  const pts1 = polyDataLeft.getPoints();
  for(let i=0; i<3; i++){
    const idx = triple[i];
    const color = colorArray[i];
    if(idx<0 || idx>=pts1.getNumberOfPoints()){
      console.warn("Invalid index on mesh1 =>", idx);
      continue;
    }
    const coord=[0,0,0];
    pts1.getPoint(idx, coord);

    // place sphere on mesh1
    const sphereSrc=vtk.Filters.Sources.vtkSphereSource.newInstance({
      radius:0.02, thetaResolution:16, phiResolution:16
    });
    const sphereMap= vtk.Rendering.Core.vtkMapper.newInstance();
    sphereMap.setInputConnection(sphereSrc.getOutputPort());
    const actor= vtk.Rendering.Core.vtkActor.newInstance();
    actor.setMapper(sphereMap);
    actor.getProperty().setColor(...color);
    actor.setPosition(...coord);
    rendererLeft.addActor(actor);
    glyphActorsLeft.push(actor);

    // map to mesh2 via vertexMapping
    if(!vertexMapping || idx>=vertexMapping.length){
      console.warn("vertexMapping missing or index out-of-range => no sphere for mesh2");
      continue;
    }
    const mesh2Idx= vertexMapping[idx];
    console.log(`mesh1 vertex ${idx} => mesh2 vertex ${mesh2Idx}`);
    if(mesh2Idx<0 || mesh2Idx>=polyDataRight.getPoints().getNumberOfPoints()){
      console.warn("mesh2Idx out of range => no sphere for mesh2");
      continue;
    }
    // place sphere on mesh2
    const coord2=[0,0,0];
    polyDataRight.getPoints().getPoint(mesh2Idx, coord2);

    const sphereSrc2= vtk.Filters.Sources.vtkSphereSource.newInstance({
      radius:0.02, thetaResolution:16, phiResolution:16
    });
    const sphereMap2= vtk.Rendering.Core.vtkMapper.newInstance();
    sphereMap2.setInputConnection(sphereSrc2.getOutputPort());
    const actor2= vtk.Rendering.Core.vtkActor.newInstance();
    actor2.setMapper(sphereMap2);
    actor2.getProperty().setColor(...color);
    actor2.setPosition(...coord2);
    rendererRight.addActor(actor2);
    glyphActorsRight.push(actor2);
  }

  renderWindowLeft.render();
  renderWindowRight.render();
  console.log("Done placing 3 points on mesh1 + 3 on mesh2.");
}

// pickFarthest3 => 3 "far-apart" vertices
function pickFarthest3(poly){
  const n = poly.getPoints().getNumberOfPoints();
  if(n<3){
    console.warn("Mesh1 has fewer than 3 vertices => can't pick 3 farthest points!");
    return [0,0,0];
  }

  // step1: random v0
  const v0 = Math.floor(Math.random()*n);
  // step2: find v1 => farthest from v0
  let best=-1, v1=0;
  const tmp0=[0,0,0], tmpX=[0,0,0];
  poly.getPoints().getPoint(v0, tmp0);
  for(let i=0; i<n; i++){
    poly.getPoints().getPoint(i, tmpX);
    const d2= distSq(tmp0, tmpX);
    if(d2>best){
      best=d2; v1=i;
    }
  }

  // step3: find v2 => farthest from set {v0,v1}
  let v2=0; best=-1;
  const tmp1=[0,0,0];
  poly.getPoints().getPoint(v1, tmp1);
  for(let i=0; i<n; i++){
    poly.getPoints().getPoint(i, tmpX);
    const d0= distSq(tmp0, tmpX);
    const d1= distSq(tmp1, tmpX);
    const minD = Math.min(d0,d1);
    if(minD>best){
      best= minD; v2=i;
    }
  }
  return [v0,v1,v2];
}
function distSq(a,b){
  const dx=b[0]-a[0], dy=b[1]-a[1], dz=b[2]-a[2];
  return dx*dx + dy*dy + dz*dz;
}
</script>
</body>
</html>
