<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mesh Correspondence and Landmarks</title>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: row;
    }
    #view1, #view2 {
      width: 50%;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }
  </style>

  <!-- Use the official package, @kitware/vtk.js, at a valid version -->
  <script 
    src="https://unpkg.com/@kitware/vtk.js@32.9.1/dist/vtk.js"
    crossorigin="anonymous">
  </script>
</head>
<body>
  <div id="view1"></div>
  <div id="view2"></div>

  <script>
    console.log("==== Starting correspondence_and_landmarks script ====");

    // ----------------------------------------------------------
    // 1) Create two side-by-side VTK views
    // ----------------------------------------------------------
    console.log("Creating side-by-side VTK render windows...");
    const fullScreenRenderWindow1 = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById('view1'),
      background: [0.2, 0.2, 0.2],
    });
    const renderer1 = fullScreenRenderWindow1.getRenderer();
    const renderWindow1 = fullScreenRenderWindow1.getRenderWindow();

    const fullScreenRenderWindow2 = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById('view2'),
      background: [0.2, 0.2, 0.2],
    });
    const renderer2 = fullScreenRenderWindow2.getRenderer();
    const renderWindow2 = fullScreenRenderWindow2.getRenderWindow();

    // ----------------------------------------------------------
    // 2) Share the camera between both renderers
    // ----------------------------------------------------------
    console.log("Sharing camera...");
    const camera = renderer1.getActiveCamera();
    renderer2.setActiveCamera(camera);

    const updateBoth = () => {
      renderWindow1.render();
      renderWindow2.render();
    };
    renderWindow1.getInteractor().onAnimation(updateBoth);
    renderWindow1.getInteractor().onEndAnimation(updateBoth);
    renderWindow2.getInteractor().onAnimation(updateBoth);
    renderWindow2.getInteractor().onEndAnimation(updateBoth);

    // ----------------------------------------------------------
    // 3) Orientation Marker
    // ----------------------------------------------------------
    console.log("Setting up orientation marker...");
    const axesActor = vtk.Rendering.Core.vtkAxesActor.newInstance();
    const orientationWidget = vtk.Interaction.Widgets.vtkOrientationMarkerWidget.newInstance({
      actor: axesActor,
      interactor: renderWindow1.getInteractor(),
    });
    orientationWidget.setOrientationMarker(axesActor);
    orientationWidget.setViewportCorner(
      vtk.Interaction.Widgets.vtkOrientationMarkerWidget.Corners.BOTTOM_LEFT
    );
    orientationWidget.setViewportSize(0.15);
    orientationWidget.setMinPixelSize(100);
    orientationWidget.setMaxPixelSize(300);
    orientationWidget.setEnabled(true);

    // ----------------------------------------------------------
    // 4) Create pipeline objects
    // ----------------------------------------------------------
    console.log("Creating pipeline objects...");
    const reader1 = vtk.IO.Core.vtkHttpDataSetReader.newInstance();
    const reader2 = vtk.IO.Core.vtkHttpDataSetReader.newInstance();

    const mapper1 = vtk.Rendering.Core.vtkMapper.newInstance();
    const actor1 = vtk.Rendering.Core.vtkActor.newInstance();
    actor1.setMapper(mapper1);

    const mapper2 = vtk.Rendering.Core.vtkMapper.newInstance();
    const actor2 = vtk.Rendering.Core.vtkActor.newInstance();
    actor2.setMapper(mapper2);

    // ----------------------------------------------------------
    // 5) Color Transfer Function
    // ----------------------------------------------------------
    console.log("Setting up Color Transfer Function...");
    const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
    lut.addRGBPoint(0.0, 0.267, 0.005, 0.329);
    lut.addRGBPoint(0.33, 0.128, 0.568, 0.551);
    lut.addRGBPoint(0.66, 0.369, 0.788, 0.382);
    lut.addRGBPoint(1.0, 0.993, 0.906, 0.144);

    mapper1.setLookupTable(lut);
    mapper1.setColorModeToMapScalars();
    mapper1.setScalarModeToUsePointFieldData();

    mapper2.setScalarModeToUsePointFieldData();
    mapper2.setColorModeToDirectScalars();

    // ----------------------------------------------------------
    // 6) Scalar bar
    // ----------------------------------------------------------
    console.log("Adding scalar bar for mesh1...");
    const scalarBarActor = vtk.Rendering.Core.vtkScalarBarActor.newInstance();
    scalarBarActor.setScalarsToColors(lut);
    scalarBarActor.setNumberOfLabels(5);
    scalarBarActor.setTitle('Mesh Scalar');

    scalarBarActor.setPosition(0.85, 0.05);
    scalarBarActor.setWidth(0.1);
    scalarBarActor.setHeight(0.4);

    renderer1.addActor(scalarBarActor);

    // ----------------------------------------------------------
    // 7) Smoothing function for mesh2 color
    // ----------------------------------------------------------
    console.log("Defining smoothing function for mesh2 color array...");
    function smoothColorArray(polyData, colorArray) {
      console.log("  -> smoothColorArray() called");
      const polys = polyData.getPolys().getData();
      const nPoints = polyData.getPoints().getNumberOfPoints();

      const adjacency = new Array(nPoints).fill(null).map(() => []);
      let idx = 0;
      while (idx < polys.length) {
        const nPts = polys[idx++];
        const cellVerts = polys.slice(idx, idx + nPts);
        idx += nPts;
        for (let a = 0; a < cellVerts.length; a++) {
          for (let b = a + 1; b < cellVerts.length; b++) {
            adjacency[cellVerts[a]].push(cellVerts[b]);
            adjacency[cellVerts[b]].push(cellVerts[a]);
          }
        }
      }

      const newColor = new Float32Array(colorArray.length);
      for (let v = 0; v < nPoints; v++) {
        const neighbors = adjacency[v];
        neighbors.push(v);
        let r = 0, g = 0, b = 0;
        for (const nb of neighbors) {
          r += colorArray[3 * nb + 0];
          g += colorArray[3 * nb + 1];
          b += colorArray[3 * nb + 2];
        }
        const count = neighbors.length;
        newColor[3 * v + 0] = r / count;
        newColor[3 * v + 1] = g / count;
        newColor[3 * v + 2] = b / count;
      }
      console.log("  -> smoothColorArray() complete");
      return newColor;
    }

    // ----------------------------------------------------------
    // 8) Fetch JSON
    // ----------------------------------------------------------
    const urlOfJson = "https://oothomas.github.io/assets/data/output_vtk_data.json";
    console.log("Fetching JSON from:", urlOfJson);

    fetch(urlOfJson)
      .then((response) => {
        console.log("  -> JSON fetch status:", response.status, response.statusText);
        return response.json();
      })
      .then((data) => {
        console.log("  -> JSON parsed. Keys in data:", Object.keys(data));
        const textEnc = new TextEncoder();
        const mesh1AB = textEnc.encode(JSON.stringify(data.mesh1)).buffer;
        const mesh2AB = textEnc.encode(JSON.stringify(data.mesh2)).buffer;

        reader1.parseAsArrayBuffer(mesh1AB);
        reader2.parseAsArrayBuffer(mesh2AB);

        const mesh1PolyData = reader1.getOutputData();
        const mesh2PolyData = reader2.getOutputData();

        console.log("  -> mesh1 vertices:", mesh1PolyData.getPoints().getNumberOfPoints());
        console.log("  -> mesh2 vertices:", mesh2PolyData.getPoints().getNumberOfPoints());

        const vertexMapping = data.vertexMapping;
        console.log("  -> vertexMapping length:", vertexMapping.length);

        // (A) mesh1 scalar array
        const nVerts1 = mesh1PolyData.getPoints().getNumberOfPoints();
        const scalars1 = new Float32Array(nVerts1);
        for (let i = 0; i < nVerts1; i++) {
          scalars1[i] = i / (nVerts1 - 1); // 0..1
        }
        const scalarData1 = vtk.Common.Core.vtkDataArray.newInstance({
          name: 'mesh1_scalars',
          values: scalars1,
          numberOfComponents: 1,
        });
        mesh1PolyData.getPointData().setScalars(scalarData1);

        // (B) Transfer color to mesh2
        const nVerts2 = mesh2PolyData.getPoints().getNumberOfPoints();
        const colors2 = new Float32Array(nVerts2 * 3);
        const counts2 = new Uint32Array(nVerts2);

        for (let i = 0; i < nVerts1; i++) {
          const mapped = vertexMapping[i];
          if (mapped >= 0 && mapped < nVerts2) {
            const c = lut.getColor(scalars1[i]); // [r, g, b]
            colors2[3 * mapped + 0] += c[0];
            colors2[3 * mapped + 1] += c[1];
            colors2[3 * mapped + 2] += c[2];
            counts2[mapped]++;
          }
        }

        // average + black defaults
        for (let v = 0; v < nVerts2; v++) {
          if (counts2[v] > 0) {
            colors2[3 * v + 0] /= counts2[v];
            colors2[3 * v + 1] /= counts2[v];
            colors2[3 * v + 2] /= counts2[v];
          }
        }

        console.log("Smoothing mesh2 color array...");
        const smoothed2 = smoothColorArray(mesh2PolyData, colors2);
        const colorData2 = vtk.Common.Core.vtkDataArray.newInstance({
          name: 'mesh2_colors',
          values: smoothed2,
          numberOfComponents: 3,
        });
        mesh2PolyData.getPointData().setScalars(colorData2);

        // Hook up to the scene
        mapper1.setInputData(mesh1PolyData);
        mapper2.setInputData(mesh2PolyData);

        renderer1.addActor(actor1);
        renderer2.addActor(actor2);

        console.log("Resetting camera & rendering...");
        renderer1.resetCamera();
        renderer2.resetCamera();
        renderWindow1.render();
        renderWindow2.render();

        console.log("==== Done! ====");
      })
      .catch((err) => {
        console.error("Failed to load JSON:", err);
      });
  </script>
</body>
</html>
