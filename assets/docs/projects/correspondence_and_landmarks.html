<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Example: Two VTK Viewers with Simplified JSON Mesh Data</title>

  <!-- Using vtk.js v25.0.0 -->
  <script src="https://unpkg.com/vtk.js@25.0.0/vtk.js"></script>
  
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
      color: #333;
    }
    h1 {
      margin-bottom: 0.5em;
      text-align: center;
    }
    /* Container to center content horizontally */
    #mainContainer {
      max-width: 1200px;
      margin: 0 auto;
    }
    /* Controls bar */
    .controls {
      margin-bottom: 1em;
    }
    select, button {
      margin-right: 10px;
    }
    /* Flex container for side-by-side viewers */
    #mainFlex {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 1em;
    }
    .flexItem {
      flex: 1 1 calc(50% - 10px);
      box-sizing: border-box;
      min-width: 0;
    }
    /* VTK container styling */
    .vtkContainer {
      width: 100%;
      height: 480px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
      position: relative;
    }
    /* Tab navigation (optional) */
    .tabLinksContainer {
      margin-bottom: 1em;
      text-align: center;
    }
    .tabButton {
      background-color: #ddd;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      margin-right: 5px;
    }
    .tabButton.active {
      background-color: #bbb;
      font-weight: bold;
    }
    .tabContent {
      display: none;
      background: #fff;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      margin-bottom: 1em;
      margin: 0 auto;
      max-width: 1200px;
    }
    .tabContent.active {
      display: block;
    }
    /* Simple spinner overlay */
    #spinner {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.6);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      color: #333;
    }
    #spinnerText {
      background: #fff;
      padding: 20px;
      border-radius: 5px;
      border: 2px solid #444;
    }
    /* Info box */
    #infoBox {
      font-weight: bold;
      margin-bottom: 10px;
    }
    /* (Optional) Instructions section */
    #instructions {
      max-width: 1200px;
      margin: 2em auto;
      background: #ffffff;
      padding: 1em;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
  </style>
</head>
<body>

<h1>Example: Two VTK Viewers with Simplified JSON Mesh Data</h1>

<div id="mainContainer">
  <!-- Tabbed Navigation (optional) -->
  <div class="tabLinksContainer">
    <button class="tabButton active" onclick="openTab('interactiveTab')">Interactive Viewer</button>
    <button class="tabButton" onclick="openTab('studyTab')">About the Study</button>
    <button class="tabButton" onclick="openTab('figuresTab')">Figures</button>
  </div>

  <!-- TAB 1: INTERACTIVE VIEWER -->
  <div id="interactiveTab" class="tabContent active">
    <div class="controls">
      <button onclick="initTwoViewers()">Initialize Two VTK Viewers</button>
    </div>
    <div id="infoBox">
      We will load two meshes (vertices and faces) from JSON and display them side-by-side.
    </div>
    <div id="spinner">
      <div id="spinnerText">Loading...</div>
    </div>
    <!-- Flex container for side-by-side viewers -->
    <div id="mainFlex">
      <div class="flexItem">
        <div id="vtkContainerLeft" class="vtkContainer"></div>
      </div>
      <div class="flexItem">
        <div id="vtkContainerRight" class="vtkContainer"></div>
      </div>
    </div>
  </div>

  <!-- TAB 2: ABOUT THE STUDY (Optional) -->
  <div id="studyTab" class="tabContent">
    <h2>About the Study</h2>
    <p><strong>Title:</strong> Decoding Shape Diversity with DISCO-AE</p>
    <p><strong>Authors &amp; Affiliations:</strong></p>
    <ul>
      <li>O. Thomas et al.</li>
      <li>Center for Developmental Biology and Regenerative Medicine, Seattle Children’s Research Institute</li>
      <li>...</li>
    </ul>
    <p><strong>Keywords:</strong> Autoencoder, Morphometrics, etc.</p>
  </div>

  <!-- TAB 3: FIGURES (Optional) -->
  <div id="figuresTab" class="tabContent">
    <h2>Key Figures</h2>
    <p>(Figure thumbnails would go here.)</p>
  </div>

  <!-- Instructions (Optional) -->
  <div id="instructions">
    <h2>How to Use This Tool</h2>
    <ol>
      <li>Click “Initialize Two VTK Viewers” to fetch JSON data and display two meshes side-by-side.</li>
      <li>Open the browser console to track progress.</li>
    </ol>
  </div>
</div>

<script>
console.log("Script loaded: Initializing tabbed navigation functions.");

function openTab(tabId) {
  console.log("openTab() called for tab:", tabId);
  const allTabs = document.querySelectorAll('.tabContent');
  allTabs.forEach(t => t.classList.remove('active'));
  const allButtons = document.querySelectorAll('.tabButton');
  allButtons.forEach(b => b.classList.remove('active'));
  const thisTab = document.getElementById(tabId);
  if (thisTab) {
    thisTab.classList.add('active');
    console.log("Tab", tabId, "is now active.");
  }
  if (tabId === 'interactiveTab') {
    allButtons[0].classList.add('active');
  } else if (tabId === 'studyTab') {
    allButtons[1].classList.add('active');
  } else if (tabId === 'figuresTab') {
    allButtons[2].classList.add('active');
  }
}

function showSpinner(flag) {
  console.log("showSpinner() called. Flag =", flag);
  const spinDiv = document.getElementById('spinner');
  spinDiv.style.display = flag ? 'flex' : 'none';
}

/***********************************************************
 * MAIN LOGIC: 2 VTK VIEWERS WITH SIMPLIFIED JSON MESH DATA
 ***********************************************************/
console.log("Script loaded: Setting up main logic for two VTK viewers.");

let fullScreenRenderWindowLeft = null;
let fullScreenRenderWindowRight = null;
let rendererLeft = null;
let rendererRight = null;
let renderWindowLeft = null;
let renderWindowRight = null;

async function initTwoViewers() {
  console.log("initTwoViewers() called.");
  showSpinner(true);
  try {
    // 1) Create left VTK viewer
    console.log("Creating left VTK viewer...");
    fullScreenRenderWindowLeft = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById('vtkContainerLeft'),
      background: [0.2, 0.2, 0.2],
      // Uncomment forceDevice if needed: forceDevice: 'webgl',
    });
    rendererLeft = fullScreenRenderWindowLeft.getRenderer();
    renderWindowLeft = fullScreenRenderWindowLeft.getRenderWindow();
    console.log("Left viewer created.");

    // 2) Create right VTK viewer
    console.log("Creating right VTK viewer...");
    fullScreenRenderWindowRight = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById('vtkContainerRight'),
      background: [0.2, 0.2, 0.2],
    });
    rendererRight = fullScreenRenderWindowRight.getRenderer();
    renderWindowRight = fullScreenRenderWindowRight.getRenderWindow();
    console.log("Right viewer created.");

    // 3) Share the camera between both viewers
    console.log("Sharing camera between viewers...");
    const camera = rendererLeft.getActiveCamera();
    rendererRight.setActiveCamera(camera);

    // 4) Sync interactor events
    console.log("Syncing interactor events...");
    const updateBoth = () => {
      renderWindowLeft.render();
      renderWindowRight.render();
    };
    renderWindowLeft.getInteractor().onStartAnimation(updateBoth);
    renderWindowLeft.getInteractor().onEndAnimation(updateBoth);
    renderWindowRight.getInteractor().onStartAnimation(updateBoth);
    renderWindowRight.getInteractor().onEndAnimation(updateBoth);

    // 5) Build pipeline objects for each viewer
    console.log("Building pipeline objects...");
    const mapperLeft = vtk.Rendering.Core.vtkMapper.newInstance();
    const actorLeft = vtk.Rendering.Core.vtkActor.newInstance();
    actorLeft.setMapper(mapperLeft);

    const mapperRight = vtk.Rendering.Core.vtkMapper.newInstance();
    const actorRight = vtk.Rendering.Core.vtkActor.newInstance();
    actorRight.setMapper(mapperRight);

    // 6) Set up color transfer function for mesh1 (left viewer)
    console.log("Setting up color transfer function...");
    const lut = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
    lut.addRGBPoint(0.0, 0.267, 0.005, 0.329);
    lut.addRGBPoint(0.33, 0.128, 0.568, 0.551);
    lut.addRGBPoint(0.66, 0.369, 0.788, 0.382);
    lut.addRGBPoint(1.0, 0.993, 0.906, 0.144);
    // IMPORTANT: Set the mapping range so that getColor() works correctly.
    lut.setMappingRange(0, 1);
    // Optionally, force building the table:
    lut.build();
    
    mapperLeft.setLookupTable(lut);
    mapperLeft.setColorModeToMapScalars();
    mapperLeft.setScalarModeToUsePointFieldData();
    // For the right viewer, use direct colors
    mapperRight.setColorModeToDirectScalars();
    mapperRight.setScalarModeToUsePointFieldData();

    // 7) Fetch JSON mesh data (simplified format)
    const urlOfJson = "https://oothomas.github.io/assets/data/output_vtk_data.json"; // Update this URL as needed
    console.log("Fetching JSON from:", urlOfJson);
    const response = await fetch(urlOfJson);
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    console.log("JSON fetched successfully.");
    const data = await response.json();
    console.log("JSON parsed successfully.");

    // 8) Process mesh1 data (vertices and faces)
    console.log("Processing mesh1 data...");
    const mesh1Vertices = data.mesh1.vertices;  // array of [x,y,z]
    const nVerts1 = mesh1Vertices.length;
    const flatPoints1 = new Float32Array(nVerts1 * 3);
    for (let i = 0; i < nVerts1; i++) {
      flatPoints1[3*i]   = mesh1Vertices[i][0];
      flatPoints1[3*i+1] = mesh1Vertices[i][1];
      flatPoints1[3*i+2] = mesh1Vertices[i][2];
    }
    const points1 = vtk.Common.Core.vtkPoints.newInstance();
    points1.setData(flatPoints1, 3);
    console.log("Mesh1: Processed", nVerts1, "points.");

    console.log("Processing mesh1 faces...");
    const mesh1Faces = data.mesh1.faces;  // array of [i,j,k]
    const nFaces1 = mesh1Faces.length;
    const flatFaces1 = new Uint32Array(nFaces1 * 4);
    for (let i = 0; i < nFaces1; i++) {
      flatFaces1[4*i]   = 3; // each face is a triangle
      flatFaces1[4*i+1] = mesh1Faces[i][0];
      flatFaces1[4*i+2] = mesh1Faces[i][1];
      flatFaces1[4*i+3] = mesh1Faces[i][2];
    }
    console.log("Mesh1: Processed", nFaces1, "faces.");

    const polyData1 = vtk.Common.DataModel.vtkPolyData.newInstance();
    polyData1.setPoints(points1);
    polyData1.getPolys().setData(flatFaces1);

    // 9) Process mesh2 data (vertices and faces)
    console.log("Processing mesh2 data...");
    const mesh2Vertices = data.mesh2.vertices;
    const nVerts2 = mesh2Vertices.length;
    const flatPoints2 = new Float32Array(nVerts2 * 3);
    for (let i = 0; i < nVerts2; i++) {
      flatPoints2[3*i]   = mesh2Vertices[i][0];
      flatPoints2[3*i+1] = mesh2Vertices[i][1];
      flatPoints2[3*i+2] = mesh2Vertices[i][2];
    }
    const points2 = vtk.Common.Core.vtkPoints.newInstance();
    points2.setData(flatPoints2, 3);
    console.log("Mesh2: Processed", nVerts2, "points.");

    console.log("Processing mesh2 faces...");
    const mesh2Faces = data.mesh2.faces;
    const nFaces2 = mesh2Faces.length;
    const flatFaces2 = new Uint32Array(nFaces2 * 4);
    for (let i = 0; i < nFaces2; i++) {
      flatFaces2[4*i]   = 3;
      flatFaces2[4*i+1] = mesh2Faces[i][0];
      flatFaces2[4*i+2] = mesh2Faces[i][1];
      flatFaces2[4*i+3] = mesh2Faces[i][2];
    }
    console.log("Mesh2: Processed", nFaces2, "faces.");

    const polyData2 = vtk.Common.DataModel.vtkPolyData.newInstance();
    polyData2.setPoints(points2);
    polyData2.getPolys().setData(flatFaces2);

    // 10) (Optional) Create a scalar array for mesh1
    console.log("Creating scalar array for mesh1...");
    const scalars1 = new Float32Array(nVerts1);
    for (let i = 0; i < nVerts1; i++) {
      scalars1[i] = i / (nVerts1 - 1);
    }
    const scalarData1 = vtk.Common.Core.vtkDataArray.newInstance({
      name: 'mesh1_scalars',
      values: scalars1,
      numberOfComponents: 1,
    });
    polyData1.getPointData().setScalars(scalarData1);
    console.log("Scalar array for mesh1 created.");

    // 11) Transfer colors from mesh1 to mesh2 using vertexMapping
    console.log("Transferring colors from mesh1 to mesh2...");
    const vertexMapping = data.vertexMapping; // e.g., an array mapping mesh1 vertex indices to mesh2 indices
    const colors2 = new Float32Array(nVerts2 * 3);
    const counts2 = new Uint32Array(nVerts2);
    for (let i = 0; i < nVerts1; i++) {
      const mapped = vertexMapping[i];
      if (mapped >= 0 && mapped < nVerts2) {
        // Get color from the LUT based on the scalar value (should be in [0,1])
        const c = lut.getColor(scalars1[i]);
        // c should be an array [r, g, b]. If not, we will see an error.
        colors2[3*mapped + 0] += c[0];
        colors2[3*mapped + 1] += c[1];
        colors2[3*mapped + 2] += c[2];
        counts2[mapped]++;
      }
    }
    for (let i = 0; i < nVerts2; i++) {
      if (counts2[i] > 0) {
        colors2[3*i + 0] /= counts2[i];
        colors2[3*i + 1] /= counts2[i];
        colors2[3*i + 2] /= counts2[i];
      }
    }
    console.log("Color transfer for mesh2 complete.");
    const colorData2 = vtk.Common.Core.vtkDataArray.newInstance({
      name: 'mesh2_colors',
      values: colors2,
      numberOfComponents: 3,
    });
    polyData2.getPointData().setScalars(colorData2);

    // 12) Hook up the polydata to the mappers
    console.log("Hooking up polydata to mappers...");
    mapperLeft.setInputData(polyData1);
    mapperRight.setInputData(polyData2);

    // 13) Add actors to the renderers
    rendererLeft.addActor(actorLeft);
    rendererRight.addActor(actorRight);
    console.log("Actors added to renderers.");

    // 14) Reset cameras and render both views
    console.log("Resetting cameras and rendering...");
    rendererLeft.resetCamera();
    rendererRight.resetCamera();
    renderWindowLeft.render();
    renderWindowRight.render();

    document.getElementById('infoBox').textContent = "Loaded and displayed two meshes side-by-side.";
    console.log("initTwoViewers() completed successfully.");
  } catch (err) {
    console.error("Error initializing viewers:", err);
    alert("Error initializing viewers: " + err.message);
  } finally {
    showSpinner(false);
  }
}
</script>

</body>
</html>
