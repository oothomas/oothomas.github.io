<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Modern vtk.js with Import Map & All Dependencies</title>
    <!-- Load es-module-shims to polyfill import map support if needed -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <!-- Import map for bare module specifiers -->
    <script type="importmap">
      {
        "imports": {
          "@babel/runtime/": "https://unpkg.com/@babel/runtime@7.20.0/",
          "d3-scale": "https://unpkg.com/d3-scale@4.0.2/dist/d3-scale.min.js",
          "fflate": "https://unpkg.com/fflate@0.8.2/umd/index.js",
          "gl-matrix": "https://unpkg.com/gl-matrix@3.4.3/cjs/index.js",
          "globalthis": "https://cdn.skypack.dev/globalthis@1.0.0",
          "seedrandom": "https://unpkg.com/seedrandom@3.0.5/seedrandom.js",
          "fast-deep-equal": "https://cdn.skypack.dev/fast-deep-equal@3.1.3",
          "shader-loader": "https://unpkg.com/shader-loader@1.3.1/index.js",
          "shelljs": "https://unpkg.com/shelljs@0.8.5/shell.js",
          "spark-md5": "https://unpkg.com/spark-md5@3.0.2/spark-md5.min.js",
          "stream-browserify": "https://unpkg.com/stream-browserify@3.0.0/index.js",
          "utif": "https://unpkg.com/utif@3.1.0/UTIF.js",
          "webworker-promise": "https://unpkg.com/webworker-promise@0.5.1/lib/index.js",
          "worker-loader": "https://unpkg.com/worker-loader@3.0.8/dist/cjs.js",
          "xmlbuilder2": "https://unpkg.com/xmlbuilder2@3.1.1/lib/xmlbuilder2.min.js"
        }
      }
    </script>
    <style>
      /* Two side-by-side containers */
      body {
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: row;
      }
      #view1,
      #view2 {
        width: 50%;
        height: 100vh;
        overflow: hidden;
        position: relative;
      }
    </style>
  </head>
  <body>
    <!-- Two containers for the two vtk.js render windows -->
    <div id="view1"></div>
    <div id="view2"></div>

    <!-- Main script using ES module imports -->
    <script type="module">
      // Import vtk.js modules from unpkg.com.
      // (Replace "@latest" with a specific version if needed.)
      import vtkFullScreenRenderWindow from "https://unpkg.com/@kitware/vtk.js@latest/Rendering/Misc/FullScreenRenderWindow.js";
      import vtkActor from "https://unpkg.com/@kitware/vtk.js@latest/Rendering/Core/Actor.js";
      import vtkMapper from "https://unpkg.com/@kitware/vtk.js@latest/Rendering/Core/Mapper.js";
      import vtkHttpDataSetReader from "https://unpkg.com/@kitware/vtk.js@latest/IO/Core/HttpDataSetReader.js";
      import vtkColorTransferFunction from "https://unpkg.com/@kitware/vtk.js@latest/Rendering/Core/ColorTransferFunction.js";
      import vtkScalarBarActor from "https://unpkg.com/@kitware/vtk.js@latest/Rendering/Core/ScalarBarActor.js";
      import vtkDataArray from "https://unpkg.com/@kitware/vtk.js@latest/Common/Core/DataArray.js";

      // 1) Create two side-by-side vtk render windows.
      const fullScreenRenderWindow1 = vtkFullScreenRenderWindow.newInstance({
        rootContainer: document.getElementById("view1"),
        background: [0.2, 0.2, 0.2],
      });
      const renderer1 = fullScreenRenderWindow1.getRenderer();
      const renderWindow1 = fullScreenRenderWindow1.getRenderWindow();

      const fullScreenRenderWindow2 = vtkFullScreenRenderWindow.newInstance({
        rootContainer: document.getElementById("view2"),
        background: [0.2, 0.2, 0.2],
      });
      const renderer2 = fullScreenRenderWindow2.getRenderer();
      const renderWindow2 = fullScreenRenderWindow2.getRenderWindow();

      // 2) Share the camera between the two renderers.
      const camera = renderer1.getActiveCamera();
      renderer2.setActiveCamera(camera);

      // Ensure both render windows update together.
      function updateBoth() {
        renderWindow1.render();
        renderWindow2.render();
      }
      renderWindow1.getInteractor().onAnimation(updateBoth);
      renderWindow1.getInteractor().onEndAnimation(updateBoth);
      renderWindow2.getInteractor().onAnimation(updateBoth);
      renderWindow2.getInteractor().onEndAnimation(updateBoth);

      // 3) Set up pipeline objects.
      const reader1 = vtkHttpDataSetReader.newInstance();
      const reader2 = vtkHttpDataSetReader.newInstance();

      const mapper1 = vtkMapper.newInstance();
      const actor1 = vtkActor.newInstance();
      actor1.setMapper(mapper1);

      const mapper2 = vtkMapper.newInstance();
      const actor2 = vtkActor.newInstance();
      actor2.setMapper(mapper2);

      // 4) Create a color transfer function (lookup table).
      const lut = vtkColorTransferFunction.newInstance();
      lut.addRGBPoint(0.0, 0.267, 0.005, 0.329);
      lut.addRGBPoint(0.33, 0.128, 0.568, 0.551);
      lut.addRGBPoint(0.66, 0.369, 0.788, 0.382);
      lut.addRGBPoint(1.0, 0.993, 0.906, 0.144);

      mapper1.setLookupTable(lut);
      mapper1.setColorModeToMapScalars();
      mapper1.setScalarModeToUsePointFieldData();

      mapper2.setScalarModeToUsePointFieldData();
      mapper2.setColorModeToDirectScalars();

      // 5) Add a scalar bar (color legend) to renderer1.
      const scalarBarActor = vtkScalarBarActor.newInstance();
      scalarBarActor.setScalarsToColors(lut);
      renderer1.addActor(scalarBarActor);

      // 6) Define a smoothing function for mesh2's color array.
      function smoothColorArray(polyData, colorArray) {
        const polys = polyData.getPolys().getData();
        const nPoints = polyData.getPoints().getNumberOfPoints();
        const adjacency = new Array(nPoints).fill(null).map(() => []);
        let idx = 0;
        while (idx < polys.length) {
          const nPts = polys[idx++];
          const cellVerts = polys.slice(idx, idx + nPts);
          idx += nPts;
          for (let a = 0; a < cellVerts.length; a++) {
            for (let b = a + 1; b < cellVerts.length; b++) {
              adjacency[cellVerts[a]].push(cellVerts[b]);
              adjacency[cellVerts[b]].push(cellVerts[a]);
            }
          }
        }
        const newColor = new Float32Array(colorArray.length);
        for (let v = 0; v < nPoints; v++) {
          const neighbors = adjacency[v].slice();
          neighbors.push(v);
          let r = 0, g = 0, b = 0;
          for (const nb of neighbors) {
            r += colorArray[3 * nb + 0];
            g += colorArray[3 * nb + 1];
            b += colorArray[3 * nb + 2];
          }
          const count = neighbors.length;
          newColor[3 * v + 0] = r / count;
          newColor[3 * v + 1] = g / count;
          newColor[3 * v + 2] = b / count;
        }
        return newColor;
      }

      // 7) Fetch JSON data, build the pipelines, and render.
      const urlOfJson = "https://oothomas.github.io/assets/data/output_vtk_data.json";
      fetch(urlOfJson)
        .then(response => response.json())
        .then(data => {
          const textEnc = new TextEncoder();
          const mesh1Buffer = textEnc.encode(JSON.stringify(data.mesh1)).buffer;
          const mesh2Buffer = textEnc.encode(JSON.stringify(data.mesh2)).buffer;

          reader1.parseAsArrayBuffer(mesh1Buffer);
          reader2.parseAsArrayBuffer(mesh2Buffer);

          const mesh1PolyData = reader1.getOutputData();
          const mesh2PolyData = reader2.getOutputData();

          const vertexMapping = data.vertexMapping;

          // (A) Create a scalar array for mesh1.
          const nVerts1 = mesh1PolyData.getPoints().getNumberOfPoints();
          const scalars1 = new Float32Array(nVerts1);
          for (let i = 0; i < nVerts1; i++) {
            scalars1[i] = i / (nVerts1 - 1);
          }
          const scalarData1 = vtkDataArray.newInstance({
            name: "mesh1_scalars",
            values: scalars1,
            numberOfComponents: 1,
          });
          mesh1PolyData.getPointData().setScalars(scalarData1);

          // (B) Transfer colors from mesh1 to mesh2 using vertex mapping.
          const nVerts2 = mesh2PolyData.getPoints().getNumberOfPoints();
          const colors2 = new Float32Array(nVerts2 * 3);
          const counts2 = new Uint32Array(nVerts2);
          for (let i = 0; i < nVerts1; i++) {
            const mapped = vertexMapping[i];
            if (mapped >= 0 && mapped < nVerts2) {
              const c = lut.getColor(scalars1[i]); // [r, g, b]
              colors2[3 * mapped + 0] += c[0];
              colors2[3 * mapped + 1] += c[1];
              colors2[3 * mapped + 2] += c[2];
              counts2[mapped]++;
            }
          }
          for (let v = 0; v < nVerts2; v++) {
            if (counts2[v] > 0) {
              colors2[3 * v + 0] /= counts2[v];
              colors2[3 * v + 1] /= counts2[v];
              colors2[3 * v + 2] /= counts2[v];
            }
          }

          // Smooth mesh2 colors.
          const smoothedColors2 = smoothColorArray(mesh2PolyData, colors2);
          const colorData2 = vtkDataArray.newInstance({
            name: "mesh2_colors",
            values: smoothedColors2,
            numberOfComponents: 3,
          });
          mesh2PolyData.getPointData().setScalars(colorData2);

          mapper1.setInputData(mesh1PolyData);
          mapper2.setInputData(mesh2PolyData);

          renderer1.addActor(actor1);
          renderer2.addActor(actor2);

          renderer1.resetCamera();
          renderer2.resetCamera();
          renderWindow1.render();
          renderWindow2.render();
        })
        .catch(err => {
          console.error("Failed to load JSON:", err);
        });
    </script>
  </body>
</html>
