<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VTK.js: Pick Nearest Vertex Example</title>
  <script src="https://unpkg.com/vtk.js@25.15.2/vtk.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #F9F9F9;
      color: #333;
    }
    h1 {
      text-align: center;
    }
    #mainContainer {
      max-width: 1200px;
      margin: 0 auto;
    }
    .vtkContainer {
      width: 100%;
      height: 480px;
      border: 1px solid #ccc;
      background-color: #EFEFEF;
      position: relative;
    }
    #mainFlex {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 1em;
    }
    .flexItem {
      flex: 1 1 calc(50% - 10px);
      box-sizing: border-box;
      min-width: 0;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.6);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      color: #333;
    }
    #spinnerText {
      background: #fff;
      padding: 20px;
      border: 2px solid #444;
      border-radius: 5px;
    }
    #infoBox {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .controls {
      margin-bottom: 1em;
      text-align: center;
    }
  </style>
</head>
<body>
<h1>VTK.js: Pick Nearest Vertex Example</h1>

<div id="mainContainer">
  <div class="controls">
    <button onclick="initViewers()">Initialize</button>
    <button id="pickBtn" onclick="startVertexPicking()" disabled>Pick Nearest Vertex</button>
    <button id="clearBtn" onclick="clearGlyph()" disabled>Clear Glyph</button>
  </div>
  <div id="infoBox">No data loaded yet.</div>
  <div id="spinner">
    <div id="spinnerText">Loading...</div>
  </div>

  <div id="mainFlex">
    <div class="flexItem">
      <div id="vtkContainerLeft" class="vtkContainer"></div>
    </div>
    <div class="flexItem">
      <div id="vtkContainerRight" class="vtkContainer"></div>
    </div>
  </div>
</div>

<script>
// -------------------- Globals --------------------
let leftView, rightView;
let rendererLeft, rendererRight, renderWindowLeft, renderWindowRight;
let meshActorLeft, meshActorRight;
let polyDataLeft = null;   // store left mesh
let glyphActor = null;
let pointPicked = false;

// Show/hide spinner
function showSpinner(flag) {
  document.getElementById("spinner").style.display = flag ? "flex" : "none";
}

// Build a vtkPolyData from vertices/faces/colors
function buildPolyData(verts, faces, colors) {
  const nVerts = verts.length;
  const nFaces = faces.length;

  // Flatten vertices
  const flatVerts = new Float32Array(nVerts * 3);
  for (let i = 0; i < nVerts; i++) {
    flatVerts[3*i + 0] = verts[i][0];
    flatVerts[3*i + 1] = verts[i][1];
    flatVerts[3*i + 2] = verts[i][2];
  }
  const pts = vtk.Common.Core.vtkPoints.newInstance();
  pts.setData(flatVerts, 3);

  // Flatten faces
  const faceArr = new Uint32Array(nFaces * 4);
  for (let i = 0; i < nFaces; i++) {
    faceArr[4*i + 0] = 3; // 3 vertices in each cell
    faceArr[4*i + 1] = faces[i][0];
    faceArr[4*i + 2] = faces[i][1];
    faceArr[4*i + 3] = faces[i][2];
  }

  const poly = vtk.Common.DataModel.vtkPolyData.newInstance();
  poly.setPoints(pts);
  poly.getPolys().setData(faceArr);

  // Flatten colors
  const cArr = vtk.Common.Core.vtkDataArray.newInstance({
    name: "Colors",
    values: new Uint8Array(colors.flat()),
    numberOfComponents: 3,
    dataType: "Uint8Array",
  });
  poly.getPointData().setScalars(cArr);

  return poly;
}

// -------------------- Init Viewers --------------------
async function initViewers() {
  console.log("initViewers() called");
  showSpinner(true);

  try {
    // 1) Create left viewer
    leftView = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById("vtkContainerLeft"),
      background: [0.2, 0.2, 0.2],
    });
    rendererLeft = leftView.getRenderer();
    renderWindowLeft = leftView.getRenderWindow();

    // 2) Create right viewer
    rightView = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({
      rootContainer: document.getElementById("vtkContainerRight"),
      background: [0.2, 0.2, 0.2],
    });
    rendererRight = rightView.getRenderer();
    renderWindowRight = rightView.getRenderWindow();

    // Share camera
    rendererRight.setActiveCamera(rendererLeft.getActiveCamera());

    // Sync interactions
    const syncRenders = () => {
      renderWindowLeft.render();
      renderWindowRight.render();
    };
    renderWindowLeft.getInteractor().onStartAnimation(syncRenders);
    renderWindowLeft.getInteractor().onEndAnimation(syncRenders);
    renderWindowRight.getInteractor().onStartAnimation(syncRenders);
    renderWindowRight.getInteractor().onEndAnimation(syncRenders);

    // 3) Create mesh actors
    const mapperLeft = vtk.Rendering.Core.vtkMapper.newInstance();
    meshActorLeft = vtk.Rendering.Core.vtkActor.newInstance();
    meshActorLeft.setMapper(mapperLeft);

    const mapperRight = vtk.Rendering.Core.vtkMapper.newInstance();
    meshActorRight = vtk.Rendering.Core.vtkActor.newInstance();
    meshActorRight.setMapper(mapperRight);

    // Make sure it's surface mode, no culling
    meshActorLeft.getProperty().setRepresentationToSurface();
    meshActorLeft.getProperty().setBackfaceCulling(false);
    meshActorLeft.getProperty().setFrontfaceCulling(false);
    meshActorLeft.setPickable(true);

    meshActorRight.getProperty().setRepresentationToSurface();
    meshActorRight.getProperty().setBackfaceCulling(false);
    meshActorRight.getProperty().setFrontfaceCulling(false);
    meshActorRight.setPickable(true);

    // 4) Fetch JSON
    const url = "https://oothomas.github.io/assets/data/mesh_data_with_colors.json";
    console.log("Fetching JSON from", url);
    const resp = await fetch(url);
    if (!resp.ok) {
      throw new Error("HTTP error: " + resp.status);
    }
    const data = await resp.json();

    // 5) Build mesh for left
    const poly1 = buildPolyData(
      data.mesh1.vertices,
      data.mesh1.faces,
      data.mesh1.colors
    );
    polyDataLeft = poly1; // store reference

    // 6) Build mesh for right
    const poly2 = buildPolyData(
      data.mesh2.vertices,
      data.mesh2.faces,
      data.mesh2.colors
    );

    // 7) Connect poly->mappers
    mapperLeft.setInputData(poly1);
    mapperLeft.setColorModeToDirectScalars();
    mapperLeft.setScalarModeToUsePointData();
    mapperLeft.setInterpolateScalarsBeforeMapping(true);

    mapperRight.setInputData(poly2);
    mapperRight.setColorModeToDirectScalars();
    mapperRight.setScalarModeToUsePointData();
    mapperRight.setInterpolateScalarsBeforeMapping(true);

    // 8) Add actors to the scene
    rendererLeft.addActor(meshActorLeft);
    rendererRight.addActor(meshActorRight);

    // 9) Reset camera, render
    rendererLeft.resetCamera();
    rendererRight.resetCamera();
    renderWindowLeft.render();
    renderWindowRight.render();

    document.getElementById("infoBox").textContent =
      "Meshes loaded. Click 'Pick Nearest Vertex' to place a glyph!";
    document.getElementById("pickBtn").disabled = false;
    console.log("Success: Meshes displayed, ready for picking!");
  }
  catch (err) {
    console.error("Init error:", err);
    alert("Error: " + err);
  }
  finally {
    showSpinner(false);
  }
}

// -------------------- Start Vertex Picking --------------------
function startVertexPicking() {
  if (pointPicked) return;

  // We'll use a PointPicker to find the closest vertex
  const pointPicker = vtk.Rendering.Core.vtkPointPicker.newInstance();
  pointPicker.setPickFromList(true); // only pick from specified actor(s)
  pointPicker.initializePickList();
  pointPicker.addPickList(meshActorLeft); // only the left mesh

  leftView.getInteractor().setPicker(pointPicker);

  // We'll do a one-time pick on left-button release
  const releaseSub = leftView.getInteractor().onLeftButtonRelease((ev) => {
    releaseSub.unsubscribe();

    const rect = leftView.getContainer().getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    // Convert DOM coords => local canvas coords
    const mouseX = (ev.position.x - rect.left) * dpr;
    const mouseY = (ev.position.y - rect.top) * dpr;
    const pickX = mouseX;
    const pickY = (rect.height * dpr) - mouseY;

    console.log("Attempt vertex-pick at:", pickX, pickY);

    // If outside container, ignore
    if (pickX < 0 || pickX > rect.width*dpr ||
        pickY < 0 || pickY > rect.height*dpr) {
      console.log("Click outside container => ignoring");
      return;
    }

    // Attempt pick
    const pickOk = pointPicker.pick([pickX, pickY, 0], rendererLeft);
    console.log("pickOk:", pickOk);

    // If success, we get a pointId
    const pointId = pointPicker.getPointId();
    console.log("Picked pointId:", pointId);
    if (pointId < 0) {
      console.log("No vertex picked => abort");
      return;
    }

    // Retrieve the 3D coords from that pointId
    const pickedCoord = [0, 0, 0];
    polyDataLeft.getPoints().getPoint(pointId, pickedCoord);
    console.log("Picked vertex coords:", pickedCoord);

    // Place a small sphere glyph at that vertex
    const sphereSource = vtk.Filters.Sources.vtkSphereSource.newInstance({
      radius: 0.02, // or something suitable
      thetaResolution: 16,
      phiResolution: 16,
    });
    const sphereMapper = vtk.Rendering.Core.vtkMapper.newInstance();
    sphereMapper.setInputConnection(sphereSource.getOutputPort());
    glyphActor = vtk.Rendering.Core.vtkActor.newInstance();
    glyphActor.setMapper(sphereMapper);
    glyphActor.getProperty().setColor(1,0,0); // red
    glyphActor.setPosition(...pickedCoord);
    rendererLeft.addActor(glyphActor);

    // Re-render
    renderWindowLeft.render();

    pointPicked = true;
    document.getElementById("pickBtn").disabled = true;
    document.getElementById("clearBtn").disabled = false;
  });
}

// -------------------- Clear the glyph --------------------
function clearGlyph() {
  if (!pointPicked) return;

  if (glyphActor) {
    rendererLeft.removeActor(glyphActor);
    glyphActor = null;
  }
  renderWindowLeft.render();

  pointPicked = false;
  document.getElementById("pickBtn").disabled = false;
  document.getElementById("clearBtn").disabled = true;
}
</script>
</body>
</html>
